<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="screen-orientation" content="landscape">
    <title>éº»å°†æ¸¸æˆ - æ¨ªå±ç‰ˆ</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Microsoft YaHei', Arial, sans-serif;
            background: linear-gradient(135deg, #1a5f3f 0%, #0d3d26 100%);
            min-height: 100vh;
            min-width: 100vw;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 10px;
            overflow: hidden;
            /* å¼ºåˆ¶æ¨ªå±æç¤º */
            touch-action: none;
        }

        /* æ¨ªå±æç¤º */
        .rotate-hint {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(135deg, #1a5f3f 0%, #0d3d26 100%);
            z-index: 9999;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: #ffd700;
            text-align: center;
        }

        .rotate-hint svg {
            width: 80px;
            height: 80px;
            margin-bottom: 20px;
            animation: rotate-icon 2s infinite;
        }

        @keyframes rotate-icon {
            0%, 100% { transform: rotate(-90deg); }
            50% { transform: rotate(90deg); }
        }

        /* ç«–å±æ—¶æ˜¾ç¤ºæç¤º */
        @media (orientation: portrait) {
            .rotate-hint {
                display: flex;
            }
            .game-container {
                display: none;
            }
            h1 {
                display: none;
            }
        }

        h1 {
            color: #ffd700;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
            margin-bottom: 15px;
            font-size: 2em;
            white-space: nowrap;
        }

        .game-container {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 15px;
            padding: 15px 20px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            width: 95vw;
            max-width: 98vw;
            overflow: hidden;
        }

        .game-info {
            display: flex;
            justify-content: center;
            gap: 30px;
            margin-bottom: 15px;
            color: white;
            font-size: 1em;
            flex-wrap: wrap;
        }

        .player-area {
            display: flex;
            flex-direction: row;
            align-items: center;
            gap: 15px;
            margin: 8px 0;
            padding: 10px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
        }

        .player-name {
            color: #ffd700;
            font-weight: bold;
            margin-bottom: 0;
            font-size: 1em;
            white-space: nowrap;
            min-width: 80px;
        }

        .tiles-container-wrapper {
            position: relative;
            flex: 1;
            overflow: hidden;
        }

        .tiles-container {
            display: flex;
            gap: 4px;
            justify-content: flex-start;
            height: 70px;
            overflow-x: auto;
            overflow-y: hidden;
            scroll-behavior: smooth;
            -webkit-overflow-scrolling: touch;
            padding: 5px;
            position: relative;
            scrollbar-width: none;
            -ms-overflow-style: none;
            overscroll-behavior-x: none;
        }

        .tiles-container::-webkit-scrollbar {
            display: none;
        }

        .tiles-container .tile {
            flex-shrink: 0;
            width: 42px;
            height: 60px;
            font-size: 1.1em;
            transition: filter 0.1s, transform 0.15s cubic-bezier(0.4, 0, 0.2, 1);
        }

        /* æ»šåŠ¨æ—¶çš„è¿åŠ¨æ¨¡ç³Šæ•ˆæœ */
        .tiles-container.scrolling .tile {
            filter: blur(1px);
        }

        .tiles-container.fast-scrolling .tile {
            filter: blur(2px);
        }

        /* ä¸­å¿ƒç¼©æ”¾æ•ˆæœ */
        .tile.center-highlight {
            transform: scale(1.15);
            z-index: 10;
        }

        /* æ»šåŠ¨å¿«æ·æŒ‰é’® */
        .scroll-nav {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-top: 5px;
        }

        /* æ»šåŠ¨é€Ÿåº¦æ˜¾ç¤ºï¼ˆè°ƒè¯•ï¼‰ */
        .scroll-speed-debug {
            position: fixed;
            top: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.7);
            color: #0f0;
            padding: 8px 12px;
            border-radius: 8px;
            font-family: monospace;
            font-size: 12px;
            z-index: 9999;
            display: none;
        }

        .scroll-speed-debug.visible {
            display: block;
        }

        .scroll-nav-btn {
            width: 28px;
            height: 28px;
            border: none;
            border-radius: 50%;
            background: rgba(255, 215, 0, 0.3);
            color: #ffd700;
            font-size: 16px;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
        }

        .scroll-nav-btn:hover {
            background: rgba(255, 215, 0, 0.5);
            transform: scale(1.1);
        }

        .scroll-nav-btn:active {
            transform: scale(0.95);
        }

        .scroll-nav-btn:disabled {
            opacity: 0.3;
            cursor: not-allowed;
            transform: none;
        }

        /* æ»šåŠ¨æŒ‡ç¤ºå™¨ */
        .scroll-indicator {
            display: flex;
            justify-content: center;
            gap: 6px;
            margin-top: 8px;
            min-height: 8px;
        }

        .scroll-dot {
            width: 6px;
            height: 6px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.3);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            cursor: pointer;
        }

        .scroll-dot:hover {
            background: rgba(255, 215, 0, 0.5);
            transform: scale(1.2);
        }

        .scroll-dot.active {
            background: #ffd700;
            width: 18px;
            border-radius: 3px;
            box-shadow: 0 0 8px rgba(255, 215, 0, 0.6);
        }

        /* è¿›åº¦æ¡æŒ‡ç¤ºå™¨ï¼ˆå¤‡ç”¨æ ·å¼ï¼‰ */
        .scroll-progress {
            width: 100%;
            height: 3px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 2px;
            margin-top: 8px;
            overflow: hidden;
        }

        .scroll-progress-bar {
            height: 100%;
            background: linear-gradient(90deg, #ffd700, #ffaa00);
            border-radius: 2px;
            transition: all 0.15s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
        }

        /* è¾¹ç•Œå¼¹æ€§è§†è§‰åé¦ˆ */
        .tiles-container.elastic-left::before,
        .tiles-container.elastic-right::after {
            content: '';
            position: absolute;
            top: 0;
            bottom: 0;
            width: 40px;
            pointer-events: none;
            z-index: 10;
            opacity: 0;
            transition: opacity 0.2s;
        }

        .tiles-container.elastic-left::before {
            left: 0;
            background: linear-gradient(90deg, rgba(255, 215, 0, 0.3), transparent);
        }

        .tiles-container.elastic-right::after {
            right: 0;
            background: linear-gradient(270deg, rgba(255, 215, 0, 0.3), transparent);
        }

        .tiles-container.elastic-left.show-hint::before,
        .tiles-container.elastic-right.show-hint::after {
            opacity: 1;
        }

        .tile {
            width: 50px;
            height: 70px;
            background: linear-gradient(145deg, #fff 0%, #f0f0f0 100%);
            border: 2px solid #888;
            border-radius: 8px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-size: 1.3em;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3),
                        inset 0 1px 0 rgba(255, 255, 255, 0.8);
            position: relative;
            user-select: none;
        }

        .tile:hover {
            transform: translateY(-10px);
            box-shadow: 0 8px 12px rgba(0, 0, 0, 0.4),
                        inset 0 1px 0 rgba(255, 255, 255, 0.8);
        }

        .tile.selected {
            transform: translateY(-15px);
            border-color: #ffd700;
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.8);
        }

        .tile-content {
            display: flex;
            flex-direction: column;
            align-items: center;
            line-height: 1;
        }

        .tile-number {
            font-size: 1.4em;
        }

        .tile-suit {
            font-size: 0.9em;
            margin-top: 2px;
        }

        /* ç‰Œçš„é¢œè‰² */
        .tile-wan { color: #c41e3a; }
        .tile-tiao { color: #228b22; }
        .tile-tong { color: #1e90ff; }
        .tile-feng { color: #000; }
        .tile-jian { color: #8b0000; }

        .tile-back {
            background: linear-gradient(145deg, #2c5f4a 0%, #1a3d2d 100%);
            border-color: #1a3d2d;
            color: transparent;
        }

        .tile-back::after {
            content: '';
            width: 30px;
            height: 50px;
            background: repeating-linear-gradient(
                45deg,
                rgba(255, 255, 255, 0.1),
                rgba(255, 255, 255, 0.1) 2px,
                transparent 2px,
                transparent 8px
            );
            border-radius: 3px;
        }

        .discarded-area {
            background: rgba(0, 0, 0, 0.2);
            padding: 15px;
            border-radius: 10px;
            min-height: 120px;
            margin: 15px 0;
        }

        .discarded-area h3 {
            color: #ffd700;
            margin-bottom: 10px;
            text-align: center;
        }

        .discarded-tiles {
            display: flex;
            flex-wrap: wrap;
            gap: 3px;
            justify-content: center;
        }

        .discarded-tiles .tile {
            width: 40px;
            height: 56px;
            font-size: 1em;
            cursor: default;
        }

        .discarded-tiles .tile:hover {
            transform: none;
        }

        .controls {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin: 20px 0;
            flex-wrap: wrap;
        }

        .btn {
            padding: 12px 30px;
            font-size: 1.1em;
            font-weight: bold;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s;
            text-transform: uppercase;
        }

        .btn-primary {
            background: linear-gradient(145deg, #ffd700 0%, #ffaa00 100%);
            color: #1a3d2d;
            box-shadow: 0 4px 15px rgba(255, 215, 0, 0.4);
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(255, 215, 0, 0.6);
        }

        .btn-secondary {
            background: linear-gradient(145deg, #4a90e2 0%, #357abd 100%);
            color: white;
            box-shadow: 0 4px 15px rgba(74, 144, 226, 0.4);
        }

        .btn-secondary:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(74, 144, 226, 0.6);
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .message {
            text-align: center;
            color: #ffd700;
            font-size: 1.3em;
            padding: 15px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            margin: 10px 0;
            min-height: 50px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .meld-area {
            display: flex;
            gap: 10px;
            margin-top: 10px;
            flex-wrap: wrap;
        }

        .meld {
            display: flex;
            gap: 2px;
            padding: 5px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 8px;
        }

        .meld .tile {
            width: 40px;
            height: 56px;
            font-size: 1em;
            cursor: default;
        }

        .ai-thinking {
            color: #4a90e2;
            font-style: italic;
        }

        /* å°å±æ¨ªå±ä¼˜åŒ– */
        @media (max-height: 500px) {
            .tile {
                width: 38px;
                height: 54px;
                font-size: 1em;
            }

            .tile-number {
                font-size: 1em;
            }

            .tile-suit {
                font-size: 0.65em;
            }

            .discarded-tiles .tile {
                width: 30px;
                height: 42px;
                font-size: 0.75em;
            }

            h1 {
                font-size: 1.5em;
                margin-bottom: 10px;
            }

            .game-container {
                padding: 10px 15px;
            }

            .btn {
                padding: 8px 16px;
                font-size: 0.9em;
            }

            .tiles-container {
                padding: 5px;
                gap: 4px;
                height: 65px;
            }

            .meld .tile {
                width: 30px;
                height: 42px;
                font-size: 0.75em;
            }

            .scroll-dot {
                width: 5px;
                height: 5px;
            }

            .scroll-dot.active {
                width: 14px;
            }

            .scroll-nav-btn {
                width: 36px;
                height: 36px;
                font-size: 18px;
            }

            /* å¢åŠ ç§»åŠ¨ç«¯æ»šåŠ¨åŒºåŸŸçš„å¯ç‚¹å‡»èŒƒå›´ */
            .tiles-container-wrapper {
                padding: 8px 0;
            }

            .tiles-container {
                padding: 12px 8px;
            }

            /* ç§»åŠ¨ç«¯æç¤ºæ–‡å­— */
            .mobile-hint {
                display: block;
                text-align: center;
                color: rgba(255, 255, 255, 0.5);
                font-size: 0.85em;
                margin-top: 4px;
            }
        }

        .winner-animation {
            animation: winPulse 0.5s ease-in-out infinite alternate;
        }

        @keyframes winPulse {
            from {
                transform: scale(1);
            }
            to {
                transform: scale(1.1);
            }
        }
    </style>
</head>
<body>
    <h1>ğŸ€„ éº»å°†æ¸¸æˆ ğŸ€„</h1>

    <div class="game-container">
        <div class="game-info">
            <div>å›åˆ: <span id="round">0</span></div>
            <div>å‰©ä½™ç‰Œ: <span id="remaining">0</span></div>
        </div>

        <!-- æ»šåŠ¨é€Ÿåº¦è°ƒè¯•æ˜¾ç¤º -->
        <div class="scroll-speed-debug" id="speed-debug">
            é€Ÿåº¦: <span id="speed-value">0</span> px/f
        </div>

        <div class="message" id="message">ç‚¹å‡»"å¼€å§‹æ¸¸æˆ"å¼€å§‹</div>

        <!-- AI ç©å®¶ 2 (ä¸Šæ–¹) -->
        <div class="player-area" id="player2-area">
            <div class="player-name">ç”µè„‘ 2</div>
            <div class="meld-area" id="player2-melds"></div>
            <div class="tiles-container-wrapper">
                <div class="tiles-container elastic-left elastic-right" id="player2-hand"></div>
                <div class="scroll-nav">
                    <button class="scroll-nav-btn" onclick="scrollToEdge('player2-hand', 'left')" title="æ»šåŠ¨åˆ°æœ€å·¦">â—€</button>
                    <div class="scroll-indicator" id="player2-indicator"></div>
                    <button class="scroll-nav-btn" onclick="scrollToEdge('player2-hand', 'right')" title="æ»šåŠ¨åˆ°æœ€å³">â–¶</button>
                </div>
                <div class="mobile-hint">åŒå‡»ç‰Œå¯å¿«é€Ÿå®šä½</div>
            </div>
        </div>

        <!-- ä¸­é—´åŒºåŸŸ -->
        <div style="display: flex; gap: 20px; justify-content: center; flex-wrap: wrap;">
            <!-- AI ç©å®¶ 1 (å·¦ä¾§) -->
            <div class="player-area" id="player1-area" style="min-width: 250px;">
                <div class="player-name">ç”µè„‘ 1</div>
                <div class="meld-area" id="player1-melds"></div>
                <div class="tiles-container-wrapper">
                    <div class="tiles-container elastic-left elastic-right" id="player1-hand"></div>
                    <div class="scroll-nav">
                        <button class="scroll-nav-btn" onclick="scrollToEdge('player1-hand', 'left')" title="æ»šåŠ¨åˆ°æœ€å·¦">â—€</button>
                        <div class="scroll-indicator" id="player1-indicator"></div>
                        <button class="scroll-nav-btn" onclick="scrollToEdge('player1-hand', 'right')" title="æ»šåŠ¨åˆ°æœ€å³">â–¶</button>
                    </div>
                    <div class="mobile-hint">åŒå‡»ç‰Œå¯å¿«é€Ÿå®šä½</div>
                </div>
            </div>

            <!-- å¼ƒç‰ŒåŒº -->
            <div class="discarded-area">
                <h3>å¼ƒç‰ŒåŒº</h3>
                <div class="discarded-tiles" id="discarded-tiles"></div>
            </div>

            <!-- AI ç©å®¶ 3 (å³ä¾§) -->
            <div class="player-area" id="player3-area" style="min-width: 250px;">
                <div class="player-name">ç”µè„‘ 3</div>
                <div class="meld-area" id="player3-melds"></div>
                <div class="tiles-container-wrapper">
                    <div class="tiles-container elastic-left elastic-right" id="player3-hand"></div>
                    <div class="scroll-nav">
                        <button class="scroll-nav-btn" onclick="scrollToEdge('player3-hand', 'left')" title="æ»šåŠ¨åˆ°æœ€å·¦">â—€</button>
                        <div class="scroll-indicator" id="player3-indicator"></div>
                        <button class="scroll-nav-btn" onclick="scrollToEdge('player3-hand', 'right')" title="æ»šåŠ¨åˆ°æœ€å³">â–¶</button>
                    </div>
                    <div class="mobile-hint">åŒå‡»ç‰Œå¯å¿«é€Ÿå®šä½</div>
                </div>
            </div>
        </div>

        <!-- ç©å®¶ (ä¸‹æ–¹) -->
        <div class="player-area" id="player0-area">
            <div class="player-name">ä½ </div>
            <div class="meld-area" id="player0-melds"></div>
            <div class="tiles-container-wrapper">
                <div class="tiles-container elastic-left elastic-right" id="player0-hand"></div>
                <div class="scroll-nav">
                    <button class="scroll-nav-btn" onclick="scrollToEdge('player0-hand', 'left')" title="æ»šåŠ¨åˆ°æœ€å·¦">â—€</button>
                    <div class="scroll-indicator" id="player0-indicator"></div>
                    <button class="scroll-nav-btn" onclick="scrollToEdge('player0-hand', 'right')" title="æ»šåŠ¨åˆ°æœ€å³">â–¶</button>
                </div>
                <div class="mobile-hint">åŒå‡»ç‰Œå¯å¿«é€Ÿå®šä½</div>
            </div>
        </div>

        <div class="controls">
            <button class="btn btn-primary" id="startBtn" onclick="startGame()">å¼€å§‹æ¸¸æˆ</button>
            <button class="btn btn-secondary" id="drawBtn" onclick="drawTile()" disabled>æ‘¸ç‰Œ</button>
            <button class="btn btn-secondary" id="discardBtn" onclick="discardTile()" disabled>æ‰“å‡ºé€‰ä¸­ç‰Œ</button>
            <button class="btn btn-primary" id="huBtn" onclick="declareHu()" disabled>èƒ¡ç‰Œ</button>
        </div>
    </div>

    <script>
        // æ¸¸æˆçŠ¶æ€
        let gameState = {
            deck: [],
            players: [
                { hand: [], melds: [], isHuman: true },
                { hand: [], melds: [], isHuman: false },
                { hand: [], melds: [], isHuman: false },
                { hand: [], melds: [], isHuman: false }
            ],
            discardedTiles: [],
            currentPlayer: 0,
            selectedTile: null,
            round: 0,
            gameOver: false,
            lastDiscarded: null
        };

        // éº»å°†ç‰Œå®šä¹‰
        const suits = {
            wan: { name: 'ä¸‡', class: 'tile-wan', tiles: ['ä¸€ä¸‡', 'äºŒä¸‡', 'ä¸‰ä¸‡', 'å››ä¸‡', 'äº”ä¸‡', 'å…­ä¸‡', 'ä¸ƒä¸‡', 'å…«ä¸‡', 'ä¹ä¸‡'] },
            tiao: { name: 'æ¡', class: 'tile-tiao', tiles: ['ä¸€æ¡', 'äºŒæ¡', 'ä¸‰æ¡', 'å››æ¡', 'äº”æ¡', 'å…­æ¡', 'ä¸ƒæ¡', 'å…«æ¡', 'ä¹æ¡'] },
            tong: { name: 'ç­’', class: 'tile-tong', tiles: ['ä¸€ç­’', 'äºŒç­’', 'ä¸‰ç­’', 'å››ç­’', 'äº”ç­’', 'å…­ç­’', 'ä¸ƒç­’', 'å…«ç­’', 'ä¹ç­’'] }
        };

        const honorTiles = [
            { name: 'ä¸œé£', class: 'tile-feng' },
            { name: 'å—é£', class: 'tile-feng' },
            { name: 'è¥¿é£', class: 'tile-feng' },
            { name: 'åŒ—é£', class: 'tile-feng' },
            { name: 'çº¢ä¸­', class: 'tile-jian' },
            { name: 'å‘è´¢', class: 'tile-jian' },
            { name: 'ç™½æ¿', class: 'tile-jian' }
        ];

        // åˆ›å»ºå®Œæ•´çš„éº»å°†ç‰Œç»„
        function createDeck() {
            let deck = [];
            let id = 0;

            // æ•°ç‰Œ (ä¸‡ã€æ¡ã€ç­’)
            for (let suitName in suits) {
                const suit = suits[suitName];
                for (let i = 0; i < 4; i++) { // æ¯ç§ç‰Œ4å¼ 
                    for (let j = 0; j < suit.tiles.length; j++) {
                        deck.push({
                            id: id++,
                            name: suit.tiles[j],
                            suit: suitName,
                            number: j + 1,
                            class: suit.class,
                            displayName: `${j + 1}${suit.name}`
                        });
                    }
                }
            }

            // å­—ç‰Œ (é£ç‰Œå’Œç®­ç‰Œ)
            for (let i = 0; i < 4; i++) {
                honorTiles.forEach((tile, index) => {
                    deck.push({
                        id: id++,
                        name: tile.name,
                        suit: 'honor',
                        number: index + 1,
                        class: tile.class,
                        displayName: tile.name
                    });
                });
            }

            return deck;
        }

        // æ´—ç‰Œ
        function shuffleDeck(deck) {
            for (let i = deck.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [deck[i], deck[j]] = [deck[j], deck[i]];
            }
            return deck;
        }

        // åˆ›å»ºç‰Œçš„ HTML
        function createTileHTML(tile, isBack = false, isSelected = false) {
            if (isBack) {
                return `<div class="tile tile-back"></div>`;
            }

            const selectedClass = isSelected ? 'selected' : '';
            const content = tile.suit === 'honor' ?
                `<div class="tile-content"><div class="tile-number">${tile.name}</div></div>` :
                `<div class="tile-content"><div class="tile-number">${tile.number}</div><div class="tile-suit">${suits[tile.suit].name}</div></div>`;

            return `<div class="tile ${tile.class} ${selectedClass}" data-id="${tile.id}" onclick="selectTile(${tile.id})" ondblclick="doubleClickTile(${tile.id})">${content}</div>`;
        }

        // æ’åºæ‰‹ç‰Œ
        function sortHand(hand) {
            return hand.sort((a, b) => {
                if (a.suit !== b.suit) {
                    const suitOrder = ['wan', 'tiao', 'tong', 'honor'];
                    return suitOrder.indexOf(a.suit) - suitOrder.indexOf(b.suit);
                }
                return a.number - b.number;
            });
        }

        // å‘ç‰Œ
        function dealCards() {
            gameState.deck = shuffleDeck(createDeck());

            // æ¯ä¸ªç©å®¶å‘13å¼ ç‰Œ
            for (let i = 0; i < 4; i++) {
                gameState.players[i].hand = [];
                gameState.players[i].melds = [];
                for (let j = 0; j < 13; j++) {
                    gameState.players[i].hand.push(gameState.deck.pop());
                }
                gameState.players[i].hand = sortHand(gameState.players[i].hand);
            }
        }

        // æ¸²æŸ“æ¸¸æˆç•Œé¢
        function render() {
            // æ¸²æŸ“ç©å®¶æ‰‹ç‰Œ
            gameState.players.forEach((player, index) => {
                const handElement = document.getElementById(`player${index}-hand`);
                const meldsElement = document.getElementById(`player${index}-melds`);

                if (player.isHuman) {
                    handElement.innerHTML = player.hand.map(tile =>
                        createTileHTML(tile, false, gameState.selectedTile === tile.id)
                    ).join('');
                } else {
                    // AI æ‰‹ç‰ŒèƒŒé¢
                    handElement.innerHTML = player.hand.map(() =>
                        createTileHTML(null, true)
                    ).join('');
                }

                // æ¸²æŸ“æ˜ç‰Œç»„
                meldsElement.innerHTML = player.melds.map(meld =>
                    `<div class="meld">${meld.map(tile => createTileHTML(tile)).join('')}</div>`
                ).join('');
            });

            // æ¸²æŸ“å¼ƒç‰ŒåŒº
            const discardedElement = document.getElementById('discarded-tiles');
            discardedElement.innerHTML = gameState.discardedTiles.map(tile =>
                createTileHTML(tile)
            ).join('');

            // æ›´æ–°æ¸¸æˆä¿¡æ¯
            document.getElementById('round').textContent = gameState.round;
            document.getElementById('remaining').textContent = gameState.deck.length;

            // æ›´æ–°æ»šåŠ¨æŒ‡ç¤ºå™¨
            setTimeout(() => {
                Object.values(scrollControllers).forEach(controller => {
                    controller.updateIndicator();
                });
            }, 50);
        }

        // é€‰æ‹©ç‰Œ
        function selectTile(tileId) {
            if (gameState.gameOver || gameState.currentPlayer !== 0) return;

            const player = gameState.players[0];
            const tile = player.hand.find(t => t.id === tileId);

            if (tile) {
                gameState.selectedTile = gameState.selectedTile === tileId ? null : tileId;
                render();

                // æ»šåŠ¨åˆ°é€‰ä¸­çš„ç‰Œ
                if (gameState.selectedTile === tileId) {
                    setTimeout(() => {
                        const tileElement = document.querySelector(`[data-id="${tileId}"]`);
                        if (tileElement) {
                            tileElement.scrollIntoView({
                                behavior: 'smooth',
                                block: 'nearest',
                                inline: 'center'
                            });
                        }
                    }, 10);
                }
            }
        }

        // åŒå‡»ç‰Œé¢å¿«é€Ÿæ»šåŠ¨åˆ°è¯¥ç‰Œï¼ˆå±…ä¸­æ˜¾ç¤ºï¼‰
        function doubleClickTile(tileId) {
            const tileElement = document.querySelector(`[data-id="${tileId}"]`);
            if (!tileElement) return;

            // å¹³æ»‘æ»šåŠ¨åˆ°ç‰Œé¢å¹¶å±…ä¸­
            tileElement.scrollIntoView({
                behavior: 'smooth',
                block: 'nearest',
                inline: 'center'
            });

            // æ·»åŠ é«˜äº®åŠ¨ç”»æ•ˆæœ
            tileElement.style.transition = 'transform 0.3s';
            tileElement.style.transform = 'scale(1.2)';
            setTimeout(() => {
                tileElement.style.transform = '';
            }, 300);
        }

        // æ‘¸ç‰Œ
        function drawTile() {
            if (gameState.gameOver || gameState.deck.length === 0) {
                setMessage('ç‰Œå·²æ‘¸å®Œï¼Œå¹³å±€ï¼');
                gameState.gameOver = true;
                return;
            }

            const currentPlayer = gameState.currentPlayer;
            const player = gameState.players[currentPlayer];

            if (player.hand.length >= 14) {
                setMessage('è¯·å…ˆæ‰“å‡ºä¸€å¼ ç‰Œ');
                return;
            }

            const tile = gameState.deck.pop();
            player.hand.push(tile);
            player.hand = sortHand(player.hand);

            render();
            updateButtons();

            if (currentPlayer === 0) {
                setMessage(`ä½ æ‘¸åˆ°äº†: ${tile.displayName}`);

                // æ£€æŸ¥æ˜¯å¦å¯ä»¥èƒ¡ç‰Œ
                if (canHu(player.hand)) {
                    document.getElementById('huBtn').disabled = false;
                    setMessage(`ä½ æ‘¸åˆ°äº†: ${tile.displayName} - å¯ä»¥èƒ¡ç‰Œï¼`);
                }
            }
        }

        // æ‰“å‡ºç‰Œ
        function discardTile() {
            if (gameState.gameOver) return;

            const currentPlayer = gameState.currentPlayer;
            const player = gameState.players[currentPlayer];

            let tileToDiscard;

            if (currentPlayer === 0) {
                // äººç±»ç©å®¶
                if (gameState.selectedTile === null) {
                    setMessage('è¯·å…ˆé€‰æ‹©ä¸€å¼ ç‰Œ');
                    return;
                }

                const tileIndex = player.hand.findIndex(t => t.id === gameState.selectedTile);
                if (tileIndex === -1) return;

                tileToDiscard = player.hand.splice(tileIndex, 1)[0];
                gameState.selectedTile = null;
            } else {
                // AI ç©å®¶
                tileToDiscard = aiSelectDiscard(player);
                const tileIndex = player.hand.findIndex(t => t.id === tileToDiscard.id);
                if (tileIndex !== -1) {
                    player.hand.splice(tileIndex, 1);
                }
            }

            gameState.discardedTiles.push(tileToDiscard);
            gameState.lastDiscarded = tileToDiscard;
            gameState.round++;

            render();

            // æ£€æŸ¥å…¶ä»–ç©å®¶æ˜¯å¦å¯ä»¥èƒ¡è¿™å¼ ç‰Œ
            if (checkOtherPlayersHu(tileToDiscard)) {
                return;
            }

            // ä¸‹ä¸€ä¸ªç©å®¶
            nextPlayer();
        }

        // AI é€‰æ‹©è¦æ‰“å‡ºçš„ç‰Œ
        function aiSelectDiscard(player) {
            // ç®€å•AIï¼šéšæœºé€‰æ‹©ä¸€å¼ ç‰Œ
            return player.hand[Math.floor(Math.random() * player.hand.length)];
        }

        // æ£€æŸ¥å…¶ä»–ç©å®¶æ˜¯å¦å¯ä»¥èƒ¡ç‰Œ
        function checkOtherPlayersHu(discardedTile) {
            for (let i = 0; i < 4; i++) {
                if (i === gameState.currentPlayer) continue;

                const player = gameState.players[i];
                const testHand = [...player.hand, discardedTile];

                if (canHu(testHand)) {
                    gameState.gameOver = true;
                    setMessage(`ç”µè„‘ ${i} èƒ¡ç‰Œäº†ï¼èƒ¡ç‰Œ: ${discardedTile.displayName}`);

                    // æ˜¾ç¤ºæ‰€æœ‰æ‰‹ç‰Œ
                    player.hand = testHand;
                    render();

                    setTimeout(() => {
                        if (confirm(`ç”µè„‘ ${i} èƒ¡ç‰Œäº†ï¼\næ˜¯å¦é‡æ–°å¼€å§‹ï¼Ÿ`)) {
                            startGame();
                        }
                    }, 1000);

                    return true;
                }
            }
            return false;
        }

        // ä¸‹ä¸€ä¸ªç©å®¶
        function nextPlayer() {
            gameState.currentPlayer = (gameState.currentPlayer + 1) % 4;

            updateButtons();

            if (gameState.currentPlayer === 0) {
                setMessage('è½®åˆ°ä½ æ‘¸ç‰Œ');
            } else {
                setMessage(`ç”µè„‘ ${gameState.currentPlayer} æ­£åœ¨æ€è€ƒ...`);
                setTimeout(() => aiTurn(), 1000);
            }
        }

        // AI å›åˆ
        function aiTurn() {
            if (gameState.gameOver) return;

            const player = gameState.players[gameState.currentPlayer];

            // æ‘¸ç‰Œ
            if (gameState.deck.length > 0) {
                const tile = gameState.deck.pop();
                player.hand.push(tile);
                player.hand = sortHand(player.hand);
                render();

                // æ£€æŸ¥æ˜¯å¦å¯ä»¥èƒ¡ç‰Œ
                if (canHu(player.hand)) {
                    gameState.gameOver = true;
                    setMessage(`ç”µè„‘ ${gameState.currentPlayer} è‡ªæ‘¸èƒ¡ç‰Œï¼`);

                    // æ˜¾ç¤ºæ‰€æœ‰æ‰‹ç‰Œ
                    const handElement = document.getElementById(`player${gameState.currentPlayer}-hand`);
                    handElement.innerHTML = player.hand.map(t => createTileHTML(t)).join('');

                    setTimeout(() => {
                        if (confirm(`ç”µè„‘ ${gameState.currentPlayer} è‡ªæ‘¸èƒ¡ç‰Œï¼\næ˜¯å¦é‡æ–°å¼€å§‹ï¼Ÿ`)) {
                            startGame();
                        }
                    }, 1000);

                    return;
                }
            } else {
                setMessage('ç‰Œå·²æ‘¸å®Œï¼Œå¹³å±€ï¼');
                gameState.gameOver = true;
                return;
            }

            // æ‰“å‡ºä¸€å¼ ç‰Œ
            setTimeout(() => discardTile(), 500);
        }

        // æ£€æŸ¥æ˜¯å¦å¯ä»¥èƒ¡ç‰Œï¼ˆç®€åŒ–ç‰ˆï¼‰
        function canHu(hand) {
            if (hand.length !== 14) return false;

            // ç®€åŒ–çš„èƒ¡ç‰Œåˆ¤æ–­ï¼šæ£€æŸ¥æ˜¯å¦æœ‰3ä¸ªåˆ»å­æˆ–é¡ºå­åŠ ä¸€å¯¹å°†
            const sortedHand = [...hand].sort((a, b) => {
                if (a.suit !== b.suit) return a.suit.localeCompare(b.suit);
                return a.number - b.number;
            });

            return tryHu(sortedHand);
        }

        // å°è¯•èƒ¡ç‰Œç»„åˆ
        function tryHu(tiles) {
            if (tiles.length === 2) {
                // å‰©ä¸¤å¼ ç‰Œï¼Œå¿…é¡»æ˜¯ç›¸åŒçš„ç‰Œï¼ˆå°†ï¼‰
                return tiles[0].name === tiles[1].name;
            }

            // å°è¯•æ‰¾ä¸€ä¸ªå°†å¹¶é€’å½’æ£€æŸ¥
            for (let i = 0; i < tiles.length - 1; i++) {
                if (tiles[i].name === tiles[i + 1].name) {
                    const remaining = tiles.filter((_, index) => index !== i && index !== i + 1);
                    if (tryRemoveSets(remaining)) {
                        return true;
                    }
                }
            }

            return false;
        }

        // å°è¯•ç§»é™¤åˆ»å­æˆ–é¡ºå­
        function tryRemoveSets(tiles) {
            if (tiles.length === 0) return true;

            // å°è¯•ç§»é™¤åˆ»å­ï¼ˆä¸‰å¼ ç›¸åŒçš„ç‰Œï¼‰
            if (tiles.length >= 3) {
                if (tiles[0].name === tiles[1].name && tiles[1].name === tiles[2].name) {
                    return tryRemoveSets(tiles.slice(3));
                }

                // å°è¯•ç§»é™¤é¡ºå­ï¼ˆä¸‰å¼ è¿ç»­çš„ç‰Œï¼Œä»…é™æ•°ç‰Œï¼‰
                if (tiles[0].suit !== 'honor') {
                    const sameSuit = tiles.filter(t => t.suit === tiles[0].suit);
                    const num1 = tiles[0].number;
                    const num2Index = sameSuit.findIndex(t => t.number === num1 + 1);
                    const num3Index = sameSuit.findIndex(t => t.number === num1 + 2);

                    if (num2Index !== -1 && num3Index !== -1) {
                        const tile2 = sameSuit[num2Index];
                        const tile3 = sameSuit[num3Index];

                        const remaining = [...tiles];
                        const idx0 = remaining.findIndex(t => t.id === tiles[0].id);
                        remaining.splice(idx0, 1);
                        const idx2 = remaining.findIndex(t => t.id === tile2.id);
                        remaining.splice(idx2, 1);
                        const idx3 = remaining.findIndex(t => t.id === tile3.id);
                        remaining.splice(idx3, 1);

                        return tryRemoveSets(remaining);
                    }
                }
            }

            return false;
        }

        // èƒ¡ç‰Œ
        function declareHu() {
            if (gameState.gameOver) return;

            const player = gameState.players[0];
            if (canHu(player.hand)) {
                gameState.gameOver = true;
                setMessage('æ­å–œï¼ä½ èƒ¡ç‰Œäº†ï¼ğŸ‰');

                const handElement = document.getElementById('player0-hand');
                handElement.classList.add('winner-animation');

                setTimeout(() => {
                    handElement.classList.remove('winner-animation');
                    if (confirm('æ­å–œï¼ä½ èƒ¡ç‰Œäº†ï¼\næ˜¯å¦é‡æ–°å¼€å§‹ï¼Ÿ')) {
                        startGame();
                    }
                }, 1000);
            } else {
                setMessage('è¿˜ä¸èƒ½èƒ¡ç‰Œ');
            }
        }

        // æ›´æ–°æŒ‰é’®çŠ¶æ€
        function updateButtons() {
            const isHumanTurn = gameState.currentPlayer === 0 && !gameState.gameOver;
            const hasDrawn = gameState.players[0].hand.length === 14;

            document.getElementById('drawBtn').disabled = !isHumanTurn || hasDrawn;
            document.getElementById('discardBtn').disabled = !isHumanTurn || !hasDrawn;
            document.getElementById('huBtn').disabled = !canHu(gameState.players[0].hand);
        }

        // è®¾ç½®æ¶ˆæ¯
        function setMessage(msg) {
            document.getElementById('message').textContent = msg;
        }

        // å¼€å§‹æ¸¸æˆ
        function startGame() {
            gameState = {
                deck: [],
                players: [
                    { hand: [], melds: [], isHuman: true },
                    { hand: [], melds: [], isHuman: false },
                    { hand: [], melds: [], isHuman: false },
                    { hand: [], melds: [], isHuman: false }
                ],
                discardedTiles: [],
                currentPlayer: 0,
                selectedTile: null,
                round: 0,
                gameOver: false,
                lastDiscarded: null
            };

            dealCards();
            render();
            updateButtons();
            setMessage('æ¸¸æˆå¼€å§‹ï¼è¯·æ‘¸ç‰Œ');

            document.getElementById('startBtn').textContent = 'é‡æ–°å¼€å§‹';
        }

        // åˆå§‹åŒ–
        render();

        // ==================== æƒ¯æ€§æ»šåŠ¨ç³»ç»Ÿ ====================
        let showSpeedDebug = false; // è°ƒè¯•å¼€å…³

        class MomentumScroller {
            constructor(element, indicatorId) {
                this.element = element;
                this.indicatorId = indicatorId;
                this.isTracking = false;
                this.lastX = 0;
                this.lastTime = 0;
                this.velocity = 0;
                this.animationId = null;
                this.totalPages = 1;
                this.currentPage = 0;
                this.startX = 0; // ç”¨äºæ£€æµ‹å¿«é€Ÿæ»‘åŠ¨
                this.startScrollLeft = 0; // ç”¨äºæ‰‹æŒ‡è·Ÿéš
                this.velocityHistory = []; // é€Ÿåº¦å†å²è®°å½•
                this.scrollBlurTimeout = null; // æ¨¡ç³Šæ•ˆæœå®šæ—¶å™¨
                this.centerHighlightTimeout = null; // ä¸­å¿ƒé«˜äº®å®šæ—¶å™¨

                this.init();
            }

            init() {
                // è§¦æ‘¸äº‹ä»¶
                this.element.addEventListener('touchstart', (e) => this.onTouchStart(e), { passive: true });
                this.element.addEventListener('touchmove', (e) => this.onTouchMove(e), { passive: true });
                this.element.addEventListener('touchend', (e) => this.onTouchEnd(e), { passive: true });

                // é¼ æ ‡äº‹ä»¶
                this.element.addEventListener('mousedown', (e) => this.onMouseDown(e));
                this.element.addEventListener('mousemove', (e) => this.onMouseMove(e));
                this.element.addEventListener('mouseup', (e) => this.onMouseUp(e));
                this.element.addEventListener('mouseleave', (e) => this.onMouseUp(e));

                // æ»šåŠ¨äº‹ä»¶
                this.element.addEventListener('scroll', () => this.onScroll(), { passive: true });

                // åˆå§‹åŒ–æŒ‡ç¤ºå™¨
                this.updateIndicator();
            }

            onTouchStart(e) {
                this.startTracking(e.touches[0].clientX);
            }

            onTouchMove(e) {
                if (!this.isTracking) return;
                this.trackMovement(e.touches[0].clientX);
            }

            onTouchEnd(e) {
                this.stopTracking();
            }

            onMouseDown(e) {
                this.startTracking(e.clientX);
                e.preventDefault();
            }

            onMouseMove(e) {
                if (!this.isTracking) return;
                this.trackMovement(e.clientX);
            }

            onMouseUp(e) {
                this.stopTracking();
            }

            startTracking(x) {
                this.isTracking = true;
                this.lastX = x;
                this.startX = x;
                this.lastTime = performance.now();
                this.velocity = 0;
                this.velocityHistory = [];
                this.startScrollLeft = this.element.scrollLeft;
                this.cancelAnimation();
                this.removeBlur();
                this.clearCenterHighlight();
            }

            trackMovement(x) {
                const now = performance.now();
                const dx = x - this.lastX;
                const totalDx = x - this.startX;
                const dt = now - this.lastTime;

                if (dt > 0) {
                    // è®¡ç®—ç¬æ—¶é€Ÿåº¦
                    const instantVelocity = dx / dt;

                    // ä¿å­˜é€Ÿåº¦å†å²
                    this.velocityHistory.push({
                        velocity: instantVelocity,
                        time: now
                    });

                    // åªä¿ç•™æœ€è¿‘100msçš„é€Ÿåº¦æ•°æ®
                    this.velocityHistory = this.velocityHistory.filter(v => now - v.time < 100);

                    // ä½¿ç”¨æŒ‡æ•°åŠ æƒå¹³å‡
                    this.velocity = this.velocity * 0.5 + instantVelocity * 0.5;
                }

                // æ‰‹æŒ‡è·Ÿéšï¼šå®æ—¶è°ƒæ•´æ»šåŠ¨ä½ç½®
                this.element.scrollLeft = this.startScrollLeft - totalDx;

                this.lastX = x;
                this.lastTime = now;

                // åº”ç”¨è½»å¾®æ¨¡ç³Šæ•ˆæœ
                this.applyBlur(Math.abs(this.velocity));

                // æ£€æŸ¥è¾¹ç•Œå¼¹æ€§
                this.checkElasticBounds();

                // æ›´æ–°é€Ÿåº¦æ˜¾ç¤ºï¼ˆè°ƒè¯•æ¨¡å¼ï¼‰
                this.updateSpeedDisplay();
            }

            stopTracking() {
                if (!this.isTracking) return;
                this.isTracking = false;

                // æ£€æµ‹å¿«é€Ÿæ»‘åŠ¨ï¼ˆflingï¼‰
                const now = performance.now();
                const recentVelocities = this.velocityHistory.filter(v => now - v.time < 50);
                let finalVelocity = this.velocity;

                if (recentVelocities.length > 0) {
                    // è®¡ç®—æœ€è¿‘50msçš„å¹³å‡é€Ÿåº¦
                    const avgVelocity = recentVelocities.reduce((sum, v) => sum + v.velocity, 0) / recentVelocities.length;

                    // å¦‚æœå¹³å‡é€Ÿåº¦å¾ˆé«˜ï¼Œä½¿ç”¨æ›´æ¿€è¿›çš„åˆé€Ÿåº¦
                    if (Math.abs(avgVelocity) > Math.abs(this.velocity) * 1.2) {
                        finalVelocity = avgVelocity * 1.3; // å¢å¼ºflingæ•ˆæœ
                    }
                }

                // æ£€æµ‹å¿«é€Ÿæ»‘åŠ¨æ‰‹åŠ¿ï¼ˆæ€»è·ç¦»çŸ­ä½†é€Ÿåº¦å¿«ï¼‰
                const totalDistance = Math.abs(this.lastX - this.startX);
                const totalTime = now - (this.velocityHistory[0]?.time || now);
                const avgSpeed = totalTime > 0 ? totalDistance / totalTime : 0;

                if (avgSpeed > 0.8 && Math.abs(finalVelocity) < 0.5) {
                    // å¿«é€Ÿæ»‘åŠ¨ä½†æœ«é€Ÿåº¦ä¸é«˜ï¼Œè¯´æ˜æ˜¯å¿«é€Ÿç”©åŠ¨
                    finalVelocity = (this.lastX < this.startX ? 1.5 : -1.5);
                }

                this.velocity = finalVelocity;

                // åº”ç”¨æƒ¯æ€§æ»šåŠ¨
                if (Math.abs(this.velocity) > 0.1) {
                    this.applyMomentum();
                } else {
                    this.checkElasticBounds();
                    this.scheduleRemoveBlur();
                    this.scheduleCenterHighlight();
                }
            }

            applyMomentum() {
                const friction = 0.96; // æ‘©æ“¦ç³»æ•°
                const minVelocity = 0.01; // æœ€å°é€Ÿåº¦é˜ˆå€¼

                const animate = () => {
                    // æ›´æ–°é€Ÿåº¦æ˜¾ç¤º
                    this.updateSpeedDisplay();

                    if (Math.abs(this.velocity) < minVelocity) {
                        this.cancelAnimation();
                        this.checkElasticBounds();
                        this.scheduleRemoveBlur();
                        this.scheduleCenterHighlight();
                        return;
                    }

                    // åº”ç”¨é€Ÿåº¦åˆ°æ»šåŠ¨ä½ç½®
                    const delta = this.velocity * 16; // çº¦60fps
                    this.element.scrollLeft -= delta;

                    // åº”ç”¨æ‘©æ“¦åŠ›
                    this.velocity *= friction;

                    // æ ¹æ®é€Ÿåº¦åº”ç”¨æ¨¡ç³Šæ•ˆæœ
                    this.applyBlur(Math.abs(this.velocity));

                    // æ£€æŸ¥è¾¹ç•Œ
                    const atLeftEdge = this.element.scrollLeft <= 0;
                    const atRightEdge = this.element.scrollLeft >= this.element.scrollWidth - this.element.clientWidth;

                    if (atLeftEdge || atRightEdge) {
                        // è¾¹ç•Œå¼¹æ€§å›å¼¹
                        this.velocity *= -0.3; // åå¼¹ç³»æ•°
                        if (Math.abs(this.velocity) < 0.5) {
                            this.cancelAnimation();
                            this.snapToEdge();
                            this.scheduleRemoveBlur();
                            this.scheduleCenterHighlight();
                            return;
                        }
                    }

                    this.animationId = requestAnimationFrame(animate);
                };

                this.cancelAnimation();
                this.animationId = requestAnimationFrame(animate);
            }

            applyBlur(velocity) {
                // æ ¹æ®é€Ÿåº¦åº”ç”¨ä¸åŒç¨‹åº¦çš„æ¨¡ç³Š
                if (velocity > 0.8) {
                    this.element.classList.add('fast-scrolling');
                    this.element.classList.remove('scrolling');
                } else if (velocity > 0.3) {
                    this.element.classList.add('scrolling');
                    this.element.classList.remove('fast-scrolling');
                } else {
                    this.element.classList.remove('scrolling', 'fast-scrolling');
                }
            }

            removeBlur() {
                this.element.classList.remove('scrolling', 'fast-scrolling');
                if (this.scrollBlurTimeout) {
                    clearTimeout(this.scrollBlurTimeout);
                    this.scrollBlurTimeout = null;
                }
            }

            scheduleRemoveBlur() {
                // å»¶è¿Ÿç§»é™¤æ¨¡ç³Šæ•ˆæœ
                if (this.scrollBlurTimeout) {
                    clearTimeout(this.scrollBlurTimeout);
                }
                this.scrollBlurTimeout = setTimeout(() => {
                    this.removeBlur();
                }, 150);
            }

            updateSpeedDisplay() {
                // ä»…åœ¨è°ƒè¯•æ¨¡å¼ä¸‹æ›´æ–°é€Ÿåº¦æ˜¾ç¤º
                if (!showSpeedDebug) return;

                const speedValue = document.getElementById('speed-value');
                if (speedValue) {
                    // å°†é€Ÿåº¦è½¬æ¢ä¸ºæ›´ç›´è§‚çš„å€¼ï¼ˆåƒç´ /å¸§ï¼‰
                    const displaySpeed = Math.abs(this.velocity * 16).toFixed(2);
                    speedValue.textContent = displaySpeed;
                }
            }

            scheduleCenterHighlight() {
                // å»¶è¿Ÿåº”ç”¨ä¸­å¿ƒé«˜äº®æ•ˆæœ
                if (this.centerHighlightTimeout) {
                    clearTimeout(this.centerHighlightTimeout);
                }
                this.centerHighlightTimeout = setTimeout(() => {
                    this.applyCenterHighlight();
                }, 100);
            }

            applyCenterHighlight() {
                // æ¸…é™¤ä¹‹å‰çš„é«˜äº®
                this.clearCenterHighlight();

                const container = this.element;
                const containerRect = container.getBoundingClientRect();
                const containerCenter = containerRect.left + containerRect.width / 2;

                const tiles = container.querySelectorAll('.tile');
                let closestTile = null;
                let closestDistance = Infinity;

                tiles.forEach(tile => {
                    const tileRect = tile.getBoundingClientRect();
                    const tileCenter = tileRect.left + tileRect.width / 2;
                    const distance = Math.abs(tileCenter - containerCenter);

                    if (distance < closestDistance && distance < tileRect.width * 0.6) {
                        closestDistance = distance;
                        closestTile = tile;
                    }
                });

                if (closestTile) {
                    closestTile.classList.add('center-highlight');
                }
            }

            clearCenterHighlight() {
                const tiles = this.element.querySelectorAll('.tile.center-highlight');
                tiles.forEach(tile => tile.classList.remove('center-highlight'));
            }

            cancelAnimation() {
                if (this.animationId) {
                    cancelAnimationFrame(this.animationId);
                    this.animationId = null;
                }
            }

            checkElasticBounds() {
                const atLeftEdge = this.element.scrollLeft <= 0;
                const atRightEdge = this.element.scrollLeft >= this.element.scrollWidth - this.element.clientWidth - 1;

                this.element.classList.toggle('show-hint', atLeftEdge || atRightEdge);
            }

            snapToEdge() {
                const maxScroll = this.element.scrollWidth - this.element.clientWidth;
                if (this.element.scrollLeft < 0) {
                    this.smoothScrollTo(0);
                } else if (this.element.scrollLeft > maxScroll) {
                    this.smoothScrollTo(maxScroll);
                }
            }

            scrollToEdge(direction) {
                const maxScroll = this.element.scrollWidth - this.element.clientWidth;
                if (direction === 'left') {
                    this.smoothScrollTo(0);
                } else {
                    this.smoothScrollTo(maxScroll);
                }
            }

            smoothScrollTo(target) {
                const start = this.element.scrollLeft;
                const distance = target - start;
                const duration = 400;
                const startTime = performance.now();

                const easeOutCubic = (t) => 1 - Math.pow(1 - t, 3);

                const animate = (currentTime) => {
                    const elapsed = currentTime - startTime;
                    const progress = Math.min(elapsed / duration, 1);
                    const easedProgress = easeOutCubic(progress);

                    this.element.scrollLeft = start + distance * easedProgress;

                    if (progress < 1) {
                        this.animationId = requestAnimationFrame(animate);
                    } else {
                        this.scheduleRemoveBlur();
                        this.scheduleCenterHighlight();
                    }
                };

                this.cancelAnimation();
                this.removeBlur();
                this.clearCenterHighlight();
                this.animationId = requestAnimationFrame(animate);
            }

            onScroll() {
                this.updateIndicator();
                this.checkElasticBounds();

                // æ»šåŠ¨æ—¶æ¸…é™¤ä¸­å¿ƒé«˜äº®
                this.clearCenterHighlight();

                // æ›´æ–°é€Ÿåº¦æ˜¾ç¤º
                this.updateSpeedDisplay();
            }

            updateIndicator() {
                const indicator = document.getElementById(this.indicatorId);
                if (!indicator) return;

                const scrollWidth = this.element.scrollWidth;
                const clientWidth = this.element.clientWidth;
                const maxScroll = scrollWidth - clientWidth;

                // å¦‚æœä¸éœ€è¦æ»šåŠ¨ï¼Œéšè—æŒ‡ç¤ºå™¨
                if (maxScroll <= 10) {
                    indicator.innerHTML = '';
                    return;
                }

                // è®¡ç®—é¡µæ•°ï¼ˆæ¯é¡µçº¦3-4å¼ ç‰Œï¼‰
                const tiles = this.element.querySelectorAll('.tile');
                const tilesPerPage = Math.floor(clientWidth / 55); // 55 = ç‰Œå®½ + gap
                this.totalPages = Math.max(1, Math.ceil(tiles.length / tilesPerPage));

                // è®¡ç®—å½“å‰é¡µ
                const scrollProgress = this.element.scrollLeft / maxScroll;
                this.currentPage = Math.round(scrollProgress * (this.totalPages - 1));

                // ç”ŸæˆæŒ‡ç¤ºå™¨ç‚¹
                let html = '';
                for (let i = 0; i < this.totalPages; i++) {
                    html += `<div class="scroll-dot ${i === this.currentPage ? 'active' : ''}"
                                  data-page="${i}"
                                  onclick="scrollToPage('${this.element.id}', ${i})"></div>`;
                }
                indicator.innerHTML = html;
            }

            scrollToPage(pageIndex) {
                const tiles = this.element.querySelectorAll('.tile');
                const tilesPerPage = Math.floor(this.element.clientWidth / 55);
                const targetTileIndex = pageIndex * tilesPerPage;

                if (tiles[targetTileIndex]) {
                    tiles[targetTileIndex].scrollIntoView({
                        behavior: 'smooth',
                        block: 'nearest',
                        inline: 'start'
                    });
                }
            }
        }

        // å…¨å±€æ»šåŠ¨æ§åˆ¶å™¨å®ä¾‹
        const scrollControllers = {};

        // åˆå§‹åŒ–æ»šåŠ¨æ§åˆ¶å™¨
        function initScrollControllers() {
            for (let i = 0; i < 4; i++) {
                const element = document.getElementById(`player${i}-hand`);
                const indicatorId = `player${i}-indicator`;
                if (element) {
                    scrollControllers[i] = new MomentumScroller(element, indicatorId);
                }
            }
        }

        // æ»šåŠ¨åˆ°æŒ‡å®šé¡µ
        function scrollToPage(elementId, pageIndex) {
            const index = parseInt(elementId.replace('player', '').replace('-hand', ''));
            if (scrollControllers[index]) {
                scrollControllers[index].scrollToPage(pageIndex);
            }
        }

        // æ»šåŠ¨åˆ°è¾¹ç¼˜
        function scrollToEdge(elementId, direction) {
            const index = parseInt(elementId.replace('player', '').replace('-hand', ''));
            if (scrollControllers[index]) {
                scrollControllers[index].scrollToEdge(direction);
            }
        }

        // é¡µé¢åŠ è½½ååˆå§‹åŒ–
        setTimeout(() => {
            initScrollControllers();
        }, 100);

        // è°ƒè¯•åŠŸèƒ½ï¼šåœ¨æ§åˆ¶å°è¾“å…¥ toggleSpeedDebug() æ¥æ˜¾ç¤º/éšè—é€Ÿåº¦è°ƒè¯•é¢æ¿
        window.toggleSpeedDebug = function() {
            showSpeedDebug = !showSpeedDebug;
            const debugPanel = document.getElementById('speed-debug');
            if (debugPanel) {
                debugPanel.classList.toggle('visible', showSpeedDebug);
            }
            console.log('é€Ÿåº¦è°ƒè¯•é¢æ¿:', showSpeedDebug ? 'å·²æ˜¾ç¤º' : 'å·²éšè—');
        };
    </script>
</body>
</html>
