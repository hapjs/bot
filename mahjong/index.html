<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<meta name="apple-mobile-web-app-capable" content="yes">
<title>éº»å°†æ¸¸æˆ</title>
<style>
/* ===== å…¨å±€é‡ç½® ===== */
* { box-sizing: border-box; margin: 0; padding: 0; -webkit-tap-highlight-color: transparent; }

html, body {
  width: 100%; height: 100%; overflow: hidden;
  background: #1a5c2a;
  font-family: 'PingFang SC', 'Microsoft YaHei', 'SimHei', sans-serif;
  user-select: none;
  -webkit-text-size-adjust: 100%;
}

/* ===== è¶…å°å±ä¼˜åŒ– ===== */
@media (max-height: 400px) {
  #app {
    grid-template-rows: 18% 64% 18%;
    grid-template-columns: 15% 70% 15%;
  }
  .tile { width: 24px !important; height: 32px !important; font-size: 10px !important; }
  .player-area { padding: 2px !important; }
  .action-bar { padding: 4px !important; }
  .action-bar button { padding: 6px 10px !important; font-size: 11px !important; }
}

/* ===== æ¨ªå±å¼ºåˆ¶æç¤º ===== */
#rotate-tip {
  display: none; position: fixed; inset: 0;
  background: #1a5c2a; color: #fff; font-size: 20px;
  justify-content: center; align-items: center;
  z-index: 9999; flex-direction: column; gap: 16px;
}
#rotate-tip svg { width: 60px; height: 60px; fill: #fff; }
@media (orientation: portrait) { #rotate-tip { display: flex; } }

/* ===== ä¸»æ¸¸æˆå®¹å™¨ï¼ˆæ¨ªå±å››æ–¹å¸ƒå±€ï¼‰===== */
#app {
  width: 100vw; height: 100vh;
  display: grid;
  grid-template-areas:
    "tl  top  tr"
    "lft cnt  rgt"
    "bl  bot  br";
  grid-template-rows: 22% 56% 22%;
  grid-template-columns: 18% 64% 18%;
  background: #1e7a38;
  position: relative;
}

/* ===== å››è§’ä¿®é¥° ===== */
.corner { background: #156030; border-radius: 4px; }
#tl { grid-area: tl; }
#tr { grid-area: tr; }
#bl { grid-area: bl; display: flex; align-items: center; justify-content: center; }
#br { grid-area: br; display: flex; align-items: center; justify-content: center; }

/* ===== ç©å®¶åŒºåŸŸå…¬å…±æ ·å¼ ===== */
.player-area {
  display: flex; align-items: center; justify-content: center;
  position: relative; overflow: visible;
}

/* å¯¹å®¶ï¼ˆä¸Šæ–¹ï¼‰*/
#area-top {
  grid-area: top;
  flex-direction: row; padding: 20px 8px 4px;
  background: rgba(0,0,0,0.15);
  border-bottom: 2px solid rgba(0,0,0,0.3);
}

/* å·¦å®¶ */
#area-left {
  grid-area: lft;
  flex-direction: column; padding: 8px 4px;
  background: rgba(0,0,0,0.12);
  border-right: 2px solid rgba(0,0,0,0.3);
}

/* å³å®¶ */
#area-right {
  grid-area: rgt;
  flex-direction: column; padding: 8px 4px;
  background: rgba(0,0,0,0.12);
  border-left: 2px solid rgba(0,0,0,0.3);
}

/* æˆ‘æ–¹ï¼ˆä¸‹æ–¹ï¼‰*/
#area-bottom {
  grid-area: bot;
  flex-direction: column; padding: 4px 6px 22px;
  background: rgba(0,0,0,0.2);
  border-top: 2px solid rgba(0,0,0,0.4);
}

/* ä¸­å¤®æ¸¸æˆåŒº */
#area-center {
  grid-area: cnt;
  display: flex; flex-direction: column;
  align-items: stretch; justify-content: flex-start;
  gap: 4px; position: relative;
  padding: 4px; overflow: visible;
}

/* ä¼˜åŒ–å¸ƒå±€ - ç¡®ä¿å†…å®¹å®Œæ•´æ˜¾ç¤º */
#area-bottom { overflow: visible; }
#area-top { overflow: visible; }
#area-left { overflow: visible; }
#area-right { overflow: visible; }

/* ===== ç‰Œé¢æ ·å¼ ===== */
.tile {
  display: inline-flex; flex-direction: column;
  align-items: center; justify-content: center;
  background: linear-gradient(145deg, #fffef0, #f0e8c8);
  border: 1px solid #c8a86c;
  border-radius: 4px;
  box-shadow: 1px 2px 3px rgba(0,0,0,0.4), inset 0 1px 0 rgba(255,255,255,0.8);
  cursor: pointer; position: relative;
  transition: transform 0.12s, box-shadow 0.12s;
  flex-shrink: 0;
}

/* ç‰ŒèƒŒ */
.tile.back {
  background: linear-gradient(145deg, #2d6e8e, #1a4d6e);
  border-color: #1a3d5e;
  cursor: default;
}
.tile.back::after {
  content: ''; position: absolute; inset: 3px;
  border: 1px solid rgba(255,255,255,0.2);
  border-radius: 2px;
  background: repeating-linear-gradient(45deg, transparent, transparent 3px, rgba(255,255,255,0.05) 3px, rgba(255,255,255,0.05) 6px);
}

/* é€‰ä¸­é«˜äº® */
.tile.selected {
  transform: translateY(-8px);
  box-shadow: 1px 6px 8px rgba(0,0,0,0.5), 0 0 0 2px #ffd700;
}

/* å¯æ‰“å‡ºæç¤º */
.tile.hint { box-shadow: 1px 2px 3px rgba(0,0,0,0.4), 0 0 0 2px #00ff88; }

/* å¯èƒ¡ç‰Œæç¤º */
.tile.win-hint { box-shadow: 1px 2px 3px rgba(0,0,0,0.4), 0 0 0 2px #ff4444; animation: winPulse 0.6s infinite alternate; }
@keyframes winPulse { from { box-shadow: 1px 2px 3px rgba(0,0,0,0.4), 0 0 0 2px #ff4444; } to { box-shadow: 1px 2px 8px rgba(0,0,0,0.5), 0 0 0 3px #ff8800; } }

/* ä¸‡å­-çº¢è‰²ï¼Œç­’å­-è“è‰²ï¼Œæ¡å­-ç»¿è‰²ï¼Œå­—ç‰Œ-é»‘è‰² */
.tile .rank { font-weight: 900; line-height: 1; }
.tile .suit { line-height: 1; }
.tile.man .rank { color: #c0392b; }
.tile.pin .rank { color: #2980b9; }
.tile.sou .rank { color: #27ae60; }
.tile.honor .rank { color: #2c3e50; font-size: 0.7em; }
.tile.honor .suit { display: none; }

/* ç¢°/åƒ/æ  ç»„åˆç‰Œæ ·å¼ */
.meld-group {
  display: inline-flex; gap: 1px;
  border: 1px solid rgba(255,165,0,0.5);
  border-radius: 4px; padding: 1px;
  background: rgba(255,165,0,0.1);
  flex-shrink: 0;
}

/* ===== ç©å®¶ä¿¡æ¯æ ‡ç­¾ ===== */
.player-label {
  position: absolute; background: rgba(0,0,0,0.6);
  color: #fff; font-size: 10px; padding: 2px 6px;
  border-radius: 10px; white-space: nowrap;
  display: flex; align-items: center; gap: 4px;
  z-index: 10;
}
.player-label .wind-badge {
  background: #8b0000; color: #ffd700;
  font-size: 9px; padding: 1px 3px; border-radius: 3px;
  font-weight: bold;
}
.player-label.dealer .wind-badge { background: #8b6914; }

/* å½“å‰è¡ŒåŠ¨è€…é«˜äº® */
.player-label.active { background: rgba(255,140,0,0.8); animation: activeGlow 0.8s infinite alternate; }
@keyframes activeGlow { from { box-shadow: 0 0 4px #ff8c00; } to { box-shadow: 0 0 12px #ff8c00; } }

/* ===== ä¸­å¤®åŒºåŸŸå†…å®¹ ===== */
#center-info {
  display: flex; align-items: center; gap: 12px;
  background: rgba(0,0,0,0.3); border-radius: 8px;
  padding: 4px 14px; color: #fff; font-size: 12px;
  align-self: center; flex-shrink: 0;
}
#center-info .info-item { display: flex; flex-direction: column; align-items: center; gap: 2px; }
#center-info .info-label { font-size: 9px; opacity: 0.7; }
#center-info .info-value { font-size: 14px; font-weight: bold; color: #ffd700; }

/* æ¡Œé¢å¼ƒç‰ŒåŒº */
#discard-pool {
  display: grid;
  grid-template-areas:
    ". top ."
    "lft mid rgt"
    ". bot .";
  grid-template-columns: 22% 56% 22%;
  grid-template-rows: auto 1fr auto;
  gap: 2px; width: 100%; flex: 1;
  overflow: hidden;
}
.discard-row {
  display: flex; flex-wrap: wrap; gap: 2px;
  justify-content: center; align-items: flex-start;
  align-content: flex-start; overflow: hidden;
}
#disc-top { grid-area: top; }
#disc-left { grid-area: lft; flex-direction: column; align-items: flex-end; }
#disc-right { grid-area: rgt; flex-direction: column; align-items: flex-start; }
#disc-bottom { grid-area: bot; }
#disc-mid { grid-area: mid; display: flex; align-items: center; justify-content: center; }

/* æœ€åæ‰“å‡ºçš„ç‰Œé«˜äº® */
.last-discard { box-shadow: 0 0 6px 2px #ffd700 !important; }

/* ===== æ“ä½œæŒ‰é’® ===== */
#action-panel {
  display: flex; gap: 6px; align-items: center; justify-content: center;
  flex-wrap: wrap; min-height: 28px;
}

.action-btn {
  padding: 5px 12px; font-size: 13px; font-weight: bold;
  border: none; border-radius: 6px; cursor: pointer;
  color: #fff; transition: transform 0.1s, opacity 0.1s;
  white-space: nowrap; min-width: 44px;
  box-shadow: 0 2px 4px rgba(0,0,0,0.3);
}
.action-btn:active { transform: scale(0.95); }
.action-btn.pass { background: #607d8b; }
.action-btn.chi { background: #2e7d32; }
.action-btn.pong { background: #1565c0; }
.action-btn.kong { background: #6a1b9a; }
.action-btn.win { background: #c62828; animation: winBtn 0.5s infinite alternate; }
@keyframes winBtn { from { background: #c62828; } to { background: #ff5252; } }
.action-btn.discard-confirm { background: #e65100; }

/* åº•éƒ¨æ‰‹ç‰ŒåŒºåŸŸ */
#my-hand-area {
  display: flex; align-items: center; gap: 2px;
  flex-wrap: nowrap; overflow-x: auto;
  padding: 2px 0;
}
#my-melds-area {
  display: flex; gap: 4px; align-items: center;
  overflow-x: auto; padding: 2px 0;
}

/* æ‘¸è¿›æ¥çš„ç‰Œï¼ˆæ–°ç‰Œï¼‰*/
.tile.new-draw { border-color: #ffd700 !important; box-shadow: 1px 2px 3px rgba(0,0,0,0.4), 0 0 4px #ffd700; }

/* ===== æ¶ˆæ¯è¦†ç›–å±‚ ===== */
#message-overlay {
  display: none; position: fixed; inset: 0;
  background: rgba(0,0,0,0.7); z-index: 100;
  justify-content: center; align-items: center;
}
#message-overlay.show { display: flex; }
#message-box {
  background: linear-gradient(145deg, #2d5a3d, #1a3d2a);
  border: 2px solid #ffd700; border-radius: 16px;
  padding: 20px 30px; color: #fff;
  text-align: center; max-width: 80vw;
}
#message-box h2 { font-size: 24px; color: #ffd700; margin-bottom: 10px; }
#message-box p { font-size: 14px; line-height: 1.6; margin-bottom: 16px; white-space: pre-wrap; }
#message-box .msg-btns { display: flex; gap: 10px; justify-content: center; }
#message-box button {
  padding: 8px 20px; border: none; border-radius: 8px;
  font-size: 14px; cursor: pointer; font-weight: bold;
  transition: opacity 0.2s;
}
#message-box button:hover { opacity: 0.85; }
#message-box .btn-primary { background: #ffd700; color: #1a3d2a; }
#message-box .btn-secondary { background: #607d8b; color: #fff; }

/* ===== å¬ç‰Œæç¤ºæ¡ ===== */
#tenpai-bar {
  position: absolute; top: 2px; left: 50%; transform: translateX(-50%);
  background: rgba(255,165,0,0.9); color: #fff;
  font-size: 11px; padding: 2px 10px; border-radius: 10px;
  white-space: nowrap; z-index: 20; display: none;
}

/* ===== AI åŠ¨ç”»ç‚¹ ===== */
.thinking-dots {
  display: none; position: absolute; bottom: 4px; left: 50%; transform: translateX(-50%);
  color: #ffd700; font-size: 16px; z-index: 10;
  animation: dots 1s infinite;
}
@keyframes dots { 0%,100%{opacity:.2} 50%{opacity:1} }
.thinking-active .thinking-dots { display: block; }

/* ===== å¾—åˆ†ç»Ÿè®¡ ===== */
#score-display {
  display: flex; gap: 8px; flex-wrap: wrap;
  justify-content: center; font-size: 11px; color: #ccc;
}
.score-item { background: rgba(0,0,0,0.3); padding: 2px 8px; border-radius: 10px; }
.score-item.me { color: #ffd700; }

/* ===== å“åº”å¼ç‰Œå°ºå¯¸ ===== */
/* åº•éƒ¨ç©å®¶æ‰‹ç‰Œ - è¾ƒå¤§ï¼Œå¯æ»šåŠ¨ */
#area-bottom .tiles-row {
  display: flex; gap: 2px; overflow-x: auto; overflow-y: hidden;
  padding: 4px 2px; min-height: 56px;
  -webkit-overflow-scrolling: touch;
  scrollbar-width: none;
}
#area-bottom .tiles-row::-webkit-scrollbar { display: none; }
#area-bottom .tile { width: 34px; height: 48px; font-size: 12px; flex-shrink: 0; }
#area-bottom .tile .rank { font-size: 14px; }
#area-bottom .tile .suit { font-size: 9px; }

/* å¯¹å®¶ï¼ˆä¸Šæ–¹ï¼‰- ä¸­ç­‰ï¼Œå› ä¸ºæ¨ªå‘æ’åˆ— */
#area-top .tiles-row {
  display: flex; gap: 1px; overflow-x: auto; overflow-y: hidden;
  padding: 2px; min-height: 36px;
  -webkit-overflow-scrolling: touch;
  scrollbar-width: none;
}
#area-top .tiles-row::-webkit-scrollbar { display: none; }
#area-top .tile { width: 22px; height: 32px; font-size: 8px; flex-shrink: 0; }
#area-top .tile .rank { font-size: 10px; }
#area-top .tile .suit { font-size: 6px; }

/* å·¦å³å®¶ - ç«–å‘ï¼Œç¨å° */
#area-left .tiles-row, #area-right .tiles-row {
  display: flex; flex-direction: column; gap: 1px;
  overflow-y: auto; overflow-x: hidden;
  padding: 2px; min-width: 24px;
  -webkit-overflow-scrolling: touch;
  scrollbar-width: none;
}
#area-left .tiles-row::-webkit-scrollbar, #area-right .tiles-row::-webkit-scrollbar { display: none; }
#area-left .tile, #area-right .tile { width: 20px; height: 28px; font-size: 7px; flex-shrink: 0; }
#area-left .tile .rank, #area-right .tile .rank { font-size: 9px; }
#area-left .tile .suit, #area-right .tile .suit { font-size: 5px; }

/* ä¸­å¤®å¼ƒç‰ŒåŒºå°ç‰Œ */
#area-center .tile { width: 18px; height: 24px; font-size: 7px; }
#area-center .tile .rank { font-size: 8px; }
#area-center .tile .suit { font-size: 5px; }

/* ç¢°/æ /åƒ å…¬å¼€ç‰ŒåŒº */
#bl .tile, #br .tile { width: 20px; height: 28px; font-size: 7px; }
#bl .tile .rank, #br .tile .rank { font-size: 9px; }

/* è¶…å°å±è¿›ä¸€æ­¥ä¼˜åŒ– */
@media (max-height: 400px) {
  #area-bottom .tile { width: 28px !important; height: 40px !important; }
  #area-top .tile { width: 18px !important; height: 26px !important; }
  #area-left .tile, #area-right .tile { width: 16px !important; height: 24px !important; }
}
</style>
</head>
<body>

<!-- ç«–å±æç¤º -->
<div id="rotate-tip">
  <svg viewBox="0 0 24 24"><path d="M16.48 2.52c3.27 1.55 5.61 4.72 5.97 8.48h1.5C23.44 4.84 20.29 1.2 16.48.02v2.5zm-6.25-.77v2.5c3.21.91 5.97 3.7 6.68 7.25h2.5c-.81-4.86-4.75-8.5-9.18-9.75zM16 10c0-2.21-1.79-4-4-4s-4 1.79-4 4 1.79 4 4 4 4-1.79 4-4zM0 16l4-4v3h12v2H4v3l-4-4z"/></svg>
  è¯·æ—‹è½¬è®¾å¤‡ä¸ºæ¨ªå±æ¨¡å¼
</div>

<!-- ä¸»ç•Œé¢ -->
<div id="app">
  <!-- å·¦ä¸Šè§’ -->
  <div id="tl" class="corner"></div>

  <!-- å¯¹å®¶ï¼ˆåŒ—ï¼Œä¸Šæ–¹ï¼‰-->
  <div id="area-top" class="player-area">
    <div id="label-top" class="player-label" style="top:2px;left:50%;transform:translateX(-50%)">
      <span class="wind-badge" id="wind-top">åŒ—</span>
      <span id="name-top">AIå¯¹å®¶</span>
      <span id="score-top" style="color:#ffd700">0</span>åˆ†
    </div>
    <div id="melds-top" style="display:flex;gap:2px;margin-right:4px"></div>
    <div id="hand-top" style="display:flex;gap:1px;flex-wrap:nowrap"></div>
    <div class="thinking-dots" id="think-top">Â·Â·Â·</div>
  </div>

  <!-- å³ä¸Šè§’ -->
  <div id="tr" class="corner"></div>

  <!-- å·¦å®¶ï¼ˆè¥¿ï¼‰-->
  <div id="area-left" class="player-area">
    <div id="label-left" class="player-label" style="top:50%;left:2px;transform:translateY(-50%)">
      <span class="wind-badge" id="wind-left">è¥¿</span>
      <span id="name-left">AIå·¦å®¶</span>
      <span id="score-left" style="color:#ffd700">0</span>åˆ†
    </div>
    <div id="melds-left" style="display:flex;flex-direction:column;gap:2px;margin-bottom:4px"></div>
    <div id="hand-left" style="display:flex;flex-direction:column;gap:1px"></div>
    <div class="thinking-dots" id="think-left">Â·Â·Â·</div>
  </div>

  <!-- ä¸­å¤®åŒºåŸŸ -->
  <div id="area-center">
    <!-- æ¸¸æˆä¿¡æ¯æ  -->
    <div id="center-info">
      <div class="info-item">
        <span class="info-label">å‰©ä½™</span>
        <span class="info-value" id="wall-count">0</span>
      </div>
      <div class="info-item">
        <span class="info-label">å±€é£</span>
        <span class="info-value" id="round-wind">ä¸œ</span>
      </div>
      <div class="info-item">
        <span class="info-label">åº„å®¶</span>
        <span class="info-value" id="dealer-name">-</span>
      </div>
      <div class="info-item">
        <span class="info-label">ç•ªæ•°</span>
        <span class="info-value" id="current-fan">-</span>
      </div>
    </div>

    <!-- å¼ƒç‰Œæ±  -->
    <div id="discard-pool">
      <div id="disc-top" class="discard-row"></div>
      <div id="disc-left" class="discard-row" style="flex-direction:column;align-items:flex-end"></div>
      <div id="disc-mid" style="color:rgba(255,255,255,0.1);font-size:48px;font-weight:bold">âŠ•</div>
      <div id="disc-right" class="discard-row" style="flex-direction:column;align-items:flex-start"></div>
      <div id="disc-bottom" class="discard-row"></div>
    </div>

    <!-- å¬ç‰Œæç¤ºæ¡ -->
    <div id="tenpai-bar">å¬ç‰Œï¼šå¾… <span id="tenpai-tiles"></span></div>
  </div>

  <!-- å³å®¶ï¼ˆä¸œï¼‰-->
  <div id="area-right" class="player-area">
    <div id="label-right" class="player-label" style="top:50%;right:2px;transform:translateY(-50%)">
      <span class="wind-badge" id="wind-right">ä¸œ</span>
      <span id="name-right">AIå³å®¶</span>
      <span id="score-right" style="color:#ffd700">0</span>åˆ†
    </div>
    <div id="melds-right" style="display:flex;flex-direction:column;gap:2px;margin-bottom:4px"></div>
    <div id="hand-right" style="display:flex;flex-direction:column;gap:1px"></div>
    <div class="thinking-dots" id="think-right">Â·Â·Â·</div>
  </div>

  <!-- å·¦ä¸‹ï¼šç©å®¶çš„å…¬å¼€ç‰Œç»„ -->
  <div id="bl" class="corner">
    <div id="melds-bottom" style="display:flex;gap:3px;flex-wrap:wrap;justify-content:center;align-items:center;padding:4px"></div>
  </div>

  <!-- æˆ‘æ–¹ï¼ˆå—ï¼Œä¸‹æ–¹ï¼‰-->
  <div id="area-bottom" class="player-area">
    <div id="label-bottom" class="player-label" style="bottom:2px;left:50%;transform:translateX(-50%)">
      <span class="wind-badge" id="wind-bottom">å—</span>
      <span>ä½ </span>
      <span id="score-bottom" style="color:#ffd700">0</span>åˆ†
    </div>
    <!-- æ‰‹ç‰Œè¡Œï¼ˆå¯æ»šåŠ¨ï¼‰ -->
    <div id="my-hand-area" class="tiles-row"></div>
    <!-- æ“ä½œæŒ‰é’® -->
    <div id="action-panel"></div>
  </div>

  <!-- å³ä¸‹ï¼šå¾—åˆ† -->
  <div id="br" class="corner">
    <div id="score-display"></div>
  </div>
</div>

<!-- æ¶ˆæ¯å¼¹çª— -->
<div id="message-overlay">
  <div id="message-box">
    <h2 id="msg-title">éº»å°†</h2>
    <p id="msg-content"></p>
    <div class="msg-btns" id="msg-btns"></div>
  </div>
</div>

<script>
'use strict';
// â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
// â•‘                   éº»å°†æ¸¸æˆæ ¸å¿ƒé€»è¾‘                           â•‘
// â•‘  136å¼ ç‰Œ | å››æ–¹å¸ƒå±€ | åƒç¢°æ èƒ¡ | æ™ºèƒ½AI | è®¡åˆ†              â•‘
// â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// ======================== å¸¸é‡å®šä¹‰ ========================

// ç‰Œå‹ç¼–ç è§„åˆ™ï¼š
// 11-19 = ä¸€ä¸‡ï½ä¹ä¸‡  21-29 = ä¸€ç­’ï½ä¹ç­’  31-39 = ä¸€æ¡ï½ä¹æ¡
// 41=ä¸œ 42=å— 43=è¥¿ 44=åŒ— 45=ä¸­ 46=å‘ 47=ç™½
const TILE_NAMES = {
  11:'ä¸€ä¸‡',12:'äºŒä¸‡',13:'ä¸‰ä¸‡',14:'å››ä¸‡',15:'äº”ä¸‡',16:'å…­ä¸‡',17:'ä¸ƒä¸‡',18:'å…«ä¸‡',19:'ä¹ä¸‡',
  21:'ä¸€ç­’',22:'äºŒç­’',23:'ä¸‰ç­’',24:'å››ç­’',25:'äº”ç­’',26:'å…­ç­’',27:'ä¸ƒç­’',28:'å…«ç­’',29:'ä¹ç­’',
  31:'ä¸€æ¡',32:'äºŒæ¡',33:'ä¸‰æ¡',34:'å››æ¡',35:'äº”æ¡',36:'å…­æ¡',37:'ä¸ƒæ¡',38:'å…«æ¡',39:'ä¹æ¡',
  41:'ä¸œ',42:'å—',43:'è¥¿',44:'åŒ—',45:'ä¸­',46:'å‘',47:'ç™½'
};

// ç»ˆç«¯ç‰Œï¼ˆä¸€ã€ä¹åŠå­—ç‰Œï¼‰ç”¨äºåä¸‰å¹ºåˆ¤æ–­
const TERMINALS = [11,19,21,29,31,39,41,42,43,44,45,46,47];

// è£è€€ç‰Œï¼ˆå­—ç‰Œï¼‰
const HONORS = [41,42,43,44,45,46,47];

// èŠ±è‰²åç§°
const SUIT_NAME = { 1:'man', 2:'pin', 3:'sou', 4:'honor' };

// åº§ä½é£ï¼š0=å—(ç©å®¶), 1=è¥¿(å·¦), 2=åŒ—(å¯¹å®¶), 3=ä¸œ(å³)
const SEAT_WINDS = ['å—','è¥¿','åŒ—','ä¸œ'];

// ======================== æ¸¸æˆçŠ¶æ€ ========================
let G = {
  wall: [],            // ç‰Œå¢™
  players: [],         // å››åç©å®¶
  current: 0,          // å½“å‰è¡ŒåŠ¨ç©å®¶ç´¢å¼•
  dealer: 0,           // åº„å®¶ç´¢å¼•
  roundWind: 41,       // å±€é£ï¼ˆä¸œ=41ï¼‰
  roundCount: 0,       // å±€æ•°
  phase: 'idle',       // æ¸¸æˆé˜¶æ®µ
  lastDiscard: null,   // æœ€åå¼ƒå‡ºçš„ç‰Œ
  lastDiscardPlayer: -1, // è°æ‰“å‡ºçš„
  pendingAction: null, // å¾…å¤„ç†åŠ¨ä½œ
  scores: [0,0,0,0],   // å„ç©å®¶ç§¯åˆ†
  selectedTile: -1,    // ç©å®¶é€‰ä¸­çš„æ‰‹ç‰Œç´¢å¼•
  newDrawIndex: -1,    // æ–°æ‘¸åˆ°çš„ç‰Œç´¢å¼•
  tenpaiTiles: [],     // å½“å‰å¬ç‰Œåˆ—è¡¨
  aiTimer: null,       // AIå»¶è¿Ÿå®šæ—¶å™¨
};

// ======================== ç©å®¶åˆå§‹åŒ– ========================
function initPlayers() {
  const names = ['ä½ ','AIå·¦å®¶','AIå¯¹å®¶','AIå³å®¶'];
  G.players = names.map((name, i) => ({
    name,
    hand: [],      // æ‰‹ç‰Œï¼ˆå·²æ’åºï¼‰
    melds: [],     // å…¬å¼€ç‰Œç»„ [{type:'pong'|'chi'|'kong', tiles:[]}]
    discards: [],  // å¼ƒç‰Œå†å²
    isHuman: i === 0,
    wind: SEAT_WINDS[i],
    isDealer: false,
  }));
}

// ======================== ç‰Œå¢™ç”Ÿæˆ ========================
function createWall() {
  const wall = [];
  // ä¸‡ç­’æ¡å„9å¼ Ã—4å‰¯ = 108å¼ 
  for (let suit = 1; suit <= 3; suit++) {
    for (let rank = 1; rank <= 9; rank++) {
      for (let copy = 0; copy < 4; copy++) {
        wall.push(suit * 10 + rank);
      }
    }
  }
  // å­—ç‰Œ7ç§Ã—4å‰¯ = 28å¼ 
  for (let h = 41; h <= 47; h++) {
    for (let copy = 0; copy < 4; copy++) {
      wall.push(h);
    }
  }
  // Fisher-Yates æ´—ç‰Œ
  for (let i = wall.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [wall[i], wall[j]] = [wall[j], wall[i]];
  }
  return wall; // 136å¼ 
}

// ======================== å‘ç‰Œ ========================
function dealHands() {
  // æ¯äººå‘13å¼ 
  for (let i = 0; i < 4; i++) {
    G.players[i].hand = G.wall.splice(0, 13);
    sortHand(G.players[i].hand);
  }
  // åº„å®¶é¢å¤–æ‘¸ä¸€å¼ ï¼ˆå…±14å¼ å…ˆæ‰“ï¼‰ï¼Œæ’åºåå®šä½æ–°ç‰Œä¸‹æ ‡
  const extraTile = G.wall.shift();
  G.players[G.dealer].hand.push(extraTile);
  sortHand(G.players[G.dealer].hand);
  const dh = G.players[G.dealer].hand;
  // å–æœ€åä¸€ä¸ªåŒå€¼ä¸‹æ ‡è¿‘ä¼¼"æ–°ç‰Œ"ä½ç½®
  let eidx = dh.length - 1;
  for (let i = dh.length - 1; i >= 0; i--) {
    if (dh[i] === extraTile) { eidx = i; break; }
  }
  G.newDrawIndex = eidx;
}

// ======================== æ‰‹ç‰Œæ’åº ========================
function sortHand(hand) {
  hand.sort((a, b) => a - b);
}

// ======================== èƒ¡ç‰Œæ£€æµ‹ ========================

/**
 * æ£€æŸ¥æ‰‹ç‰Œæ˜¯å¦å¯ä»¥èƒ¡ç‰Œ
 * @param {number[]} hand - æ‰‹ç‰Œ
 * @param {Object[]} melds - å·²å…¬å¼€çš„ç‰Œç»„
 * @returns {Object|null} èƒ¡ç‰Œç±»å‹ä¿¡æ¯ï¼Œnullè¡¨ç¤ºä¸èƒ½èƒ¡
 */
function checkWin(hand, melds) {
  const allTiles = [...hand];
  // åŠ ä¸Šå…¬å¼€ç‰Œç»„ä¸­çš„ç‰Œ
  for (const m of melds) allTiles.push(...m.tiles);

  // 1. æ£€æŸ¥ä¸ƒå¯¹ï¼ˆéœ€14å¼ æ‰‹ç‰Œï¼Œæ— å…¬å¼€ç‰Œç»„ï¼‰
  if (melds.length === 0 && hand.length === 14) {
    if (isSevenPairs(hand)) return { type: 'sevenPairs', name: 'ä¸ƒå¯¹' };
  }

  // 2. æ£€æŸ¥åä¸‰å¹ºï¼ˆéœ€14å¼ æ‰‹ç‰Œï¼Œæ— å…¬å¼€ç‰Œç»„ï¼‰
  if (melds.length === 0 && hand.length === 14) {
    if (isThirteenOrphans(hand)) return { type: 'thirteenOrphans', name: 'åä¸‰å¹º' };
  }

  // 3. æ ‡å‡†èƒ¡ç‰Œï¼š4ç»„é¢å­+1å°†
  const needMelds = 4 - melds.length; // è¿˜éœ€å‡‘å‡ ç»„é¢å­
  if (isStandardWin([...hand], needMelds)) return { type: 'standard', name: 'èƒ¡' };

  return null;
}

/** ä¸ƒå¯¹ï¼š14å¼ ç‰Œæ°å¥½7å¯¹ */
function isSevenPairs(hand) {
  if (hand.length !== 14) return false;
  const counts = countTiles(hand);
  const pairs = Object.values(counts).filter(v => v === 2);
  return pairs.length === 7;
}

/** åä¸‰å¹ºï¼šæ¯ç§ç»ˆç«¯ç‰Œ/å­—ç‰Œå„è‡³å°‘ä¸€å¼ ï¼Œå¦æœ‰ä¸€å¼ é‡å¤ */
function isThirteenOrphans(hand) {
  if (hand.length !== 14) return false;
  const counts = countTiles(hand);
  // å¿…é¡»åŒ…å«æ‰€æœ‰13ç§ç»ˆç«¯ç‰Œ
  for (const t of TERMINALS) {
    if (!counts[t] || counts[t] === 0) return false;
  }
  // æ°å¥½æœ‰ä¸€ç§ç»ˆç«¯ç‰Œæœ‰2å¼ ï¼ˆå°†ï¼‰
  const doubles = TERMINALS.filter(t => counts[t] >= 2);
  return doubles.length === 1;
}

/**
 * æ ‡å‡†èƒ¡ç‰Œé€’å½’æ£€æŸ¥ï¼šèƒ½å¦å°†tilesåˆ†è§£ä¸ºneedMeldsç»„é¢å­
 * æœ€ç»ˆå¿…é¡»ä»…å‰©1å°†ï¼ˆ2å¼ ç›¸åŒï¼‰
 */
function isStandardWin(tiles, needMelds) {
  // åŸºç¡€æƒ…å†µï¼šè¿˜éœ€0ç»„é¢å­ï¼Œåˆ™tileså¿…é¡»æ˜¯1å°†ï¼ˆ2å¼ ç›¸åŒï¼‰
  if (needMelds === 0) {
    if (tiles.length !== 2) return false;
    return tiles[0] === tiles[1];
  }
  if (tiles.length < 2) return false;

  const sorted = [...tiles].sort((a, b) => a - b);

  // å°è¯•ä»¥ç¬¬ä¸€å¼ ç‰Œä½œå°†
  // ç¬¬ä¸€ç§ï¼šå…ˆæå–å°†ï¼Œå†åˆ†è§£é¢å­
  // ä¸ºé¿å…é‡å¤ï¼Œå…ˆæ‰¾å°†ï¼Œå†æ‰¾é¢å­

  // ç­–ç•¥ï¼šæšä¸¾å“ªä¸¤å¼ ä½œå°†ï¼Œç„¶åå¯¹å‰©ä½™ç‰Œæ‰¾é¢å­
  // ä¼˜åŒ–ï¼šåªæšä¸¾ç¬¬ä¸€å¼ ä¸æ‰€æœ‰ç›¸åŒç‰Œé…å¯¹
  const first = sorted[0];

  // æ‰¾å°†ï¼šå°†ç¬¬ä¸€å¼ é…å¯¹
  const withoutFirst = sorted.slice(1);
  const pairIdx = withoutFirst.indexOf(first);
  if (pairIdx !== -1) {
    const remaining = [...withoutFirst];
    remaining.splice(pairIdx, 1);
    if (canFormAllMelds(remaining, needMelds)) return true;
  }

  // ä¸ç”¨ç¬¬ä¸€å¼ ä½œå°†ï¼Œå°è¯•ç”¨ç¬¬ä¸€å¼ ç»„æˆé¢å­
  // åˆ»å­ï¼ˆä¸‰å¼ ç›¸åŒï¼‰
  const copy = [...sorted];
  const a1 = copy.indexOf(first);
  const a2 = copy.indexOf(first, a1 + 1);
  const a3 = copy.indexOf(first, a2 + 1);
  if (a3 !== -1) {
    copy.splice(a3, 1); copy.splice(a2, 1); copy.splice(a1, 1);
    if (isStandardWin(copy, needMelds - 1)) return true;
  }

  // é¡ºå­ï¼ˆä¸‰å¼ è¿ç»­ï¼Œåªé’ˆå¯¹ä¸‡ç­’æ¡ï¼‰
  if (first < 40) { // å­—ç‰Œä¸èƒ½ç»„é¡ºå­
    const suit = Math.floor(first / 10);
    const rank = first % 10;
    if (rank <= 7) {
      const b = suit * 10 + rank + 1;
      const c = suit * 10 + rank + 2;
      const copy2 = [...sorted];
      const bi = copy2.indexOf(b);
      const ci = copy2.indexOf(c);
      if (bi !== -1 && ci !== -1) {
        // ç§»é™¤ first, b, c
        copy2.splice(ci, 1);
        copy2.splice(bi, 1);
        copy2.splice(copy2.indexOf(first), 1);
        if (isStandardWin(copy2, needMelds - 1)) return true;
      }
    }
  }

  return false;
}

/** æ£€æŸ¥ç»™å®šç‰Œæ˜¯å¦å¯ä»¥å…¨éƒ¨ç»„æˆé¢å­ï¼ˆåˆ»å­æˆ–é¡ºå­ï¼‰ */
function canFormAllMelds(tiles, count) {
  if (count === 0) return tiles.length === 0;
  if (tiles.length < 3) return false;

  const sorted = [...tiles].sort((a, b) => a - b);
  const first = sorted[0];

  // åˆ»å­
  const c1 = sorted.indexOf(first);
  const c2 = sorted.indexOf(first, c1 + 1);
  const c3 = sorted.indexOf(first, c2 + 1);
  if (c3 !== -1) {
    const copy = [...sorted];
    copy.splice(c3, 1); copy.splice(c2, 1); copy.splice(c1, 1);
    if (canFormAllMelds(copy, count - 1)) return true;
  }

  // é¡ºå­
  if (first < 40) {
    const suit = Math.floor(first / 10);
    const rank = first % 10;
    if (rank <= 7) {
      const b = suit * 10 + rank + 1;
      const c = suit * 10 + rank + 2;
      const copy2 = [...sorted];
      const bi = copy2.indexOf(b);
      const ci = copy2.indexOf(c);
      if (bi !== -1 && ci !== -1) {
        copy2.splice(ci, 1);
        copy2.splice(bi, 1);
        copy2.splice(copy2.indexOf(first), 1);
        if (canFormAllMelds(copy2, count - 1)) return true;
      }
    }
  }

  return false;
}

// ======================== å¬ç‰Œæ£€æµ‹ ========================

/**
 * æ£€æµ‹æ‰‹ç‰Œæ˜¯å¦å¤„äºå¬ç‰ŒçŠ¶æ€
 * @param {number[]} hand - æ‰‹ç‰Œï¼ˆ13å¼ ï¼‰
 * @param {Object[]} melds - å…¬å¼€ç‰Œç»„
 * @returns {number[]} å¯ä»¥èƒ¡çš„ç‰Œåˆ—è¡¨
 */
function getTenpaiTiles(hand, melds) {
  if (hand.length !== 13) return [];
  const waiting = [];
  // éå†æ‰€æœ‰å¯èƒ½çš„ç‰Œï¼ˆ136å¼ ç‰Œä¸­æ¯ç§ç‰Œï¼‰
  const allTileTypes = [];
  for (let suit = 1; suit <= 3; suit++) {
    for (let rank = 1; rank <= 9; rank++) allTileTypes.push(suit * 10 + rank);
  }
  for (let h = 41; h <= 47; h++) allTileTypes.push(h);

  for (const t of allTileTypes) {
    const testHand = [...hand, t];
    if (checkWin(testHand, melds)) waiting.push(t);
  }
  return waiting;
}

// ======================== åƒç¢°æ åˆ¤æ–­ ========================

/**
 * æ£€æŸ¥æ˜¯å¦å¯ä»¥åƒç‰Œ
 * åƒç‰Œè§„åˆ™ï¼šåªèƒ½åƒä¸Šå®¶æ‰“å‡ºçš„ç‰Œï¼Œå­—ç‰Œä¸èƒ½åƒ
 * @param {number[]} hand - æ‰‹ç‰Œ
 * @param {number} tile - è¦åƒçš„ç‰Œ
 * @returns {number[][]} å¯åƒçš„ç»„åˆåˆ—è¡¨
 */
function getChiOptions(hand, tile) {
  if (tile >= 40) return []; // å­—ç‰Œä¸èƒ½åƒ
  const suit = Math.floor(tile / 10);
  const rank = tile % 10;
  const options = [];

  // ä¸‰ç§å¯èƒ½çš„é¡ºå­ç»„åˆï¼štileæ˜¯é¡ºå­çš„ç¬¬1ã€2ã€3å¼ 
  const combos = [
    [rank - 2, rank - 1],  // tileæ˜¯é¡ºå­æœ«ä½
    [rank - 1, rank + 1],  // tileæ˜¯é¡ºå­ä¸­ä½
    [rank + 1, rank + 2],  // tileæ˜¯é¡ºå­é¦–ä½
  ];

  for (const [r1, r2] of combos) {
    if (r1 >= 1 && r2 <= 9) {
      const t1 = suit * 10 + r1;
      const t2 = suit * 10 + r2;
      // æ£€æŸ¥æ‰‹ç‰Œä¸­æ˜¯å¦æœ‰è¿™ä¸¤å¼ 
      const handCopy = [...hand];
      const i1 = handCopy.indexOf(t1);
      if (i1 !== -1) {
        handCopy.splice(i1, 1);
        const i2 = handCopy.indexOf(t2);
        if (i2 !== -1) {
          options.push([t1, tile, t2].sort((a, b) => a - b));
        }
      }
    }
  }
  return options;
}

/**
 * æ£€æŸ¥æ˜¯å¦å¯ä»¥ç¢°ç‰Œ
 * @param {number[]} hand - æ‰‹ç‰Œ
 * @param {number} tile - è¦ç¢°çš„ç‰Œ
 */
function canPong(hand, tile) {
  return hand.filter(t => t === tile).length >= 2;
}

/**
 * æ£€æŸ¥æ˜¯å¦å¯ä»¥æ ç‰Œï¼ˆæ˜æ ï¼šåˆ«äººæ‰“å‡ºï¼Œæ‰‹é‡Œæœ‰3å¼ ï¼‰
 * @param {number[]} hand - æ‰‹ç‰Œ
 * @param {number} tile - è¦æ çš„ç‰Œ
 */
function canKong(hand, tile) {
  return hand.filter(t => t === tile).length >= 3;
}

/**
 * æ£€æŸ¥æš—æ /åŠ æ ï¼ˆæ‰‹ç‰Œè‡ªæ‘¸åï¼‰
 * æš—æ ï¼šæ‰‹é‡Œ4å¼ ç›¸åŒ
 * åŠ æ ï¼šå·²ç¢°çš„ç‰Œå†æ‘¸åˆ°ç¬¬4å¼ 
 */
function getSelfKongOptions(hand, melds) {
  const options = [];
  const counts = countTiles(hand);

  // æš—æ ï¼šæ‰‹é‡Œ4å¼ 
  for (const [tile, count] of Object.entries(counts)) {
    if (count >= 4) options.push({ type: 'anKong', tile: parseInt(tile) });
  }

  // åŠ æ ï¼šå·²ç¢°çš„ç‰Œæ‘¸åˆ°ç¬¬4å¼ 
  for (const meld of melds) {
    if (meld.type === 'pong') {
      const pt = meld.tiles[0];
      if (counts[pt] >= 1) options.push({ type: 'addKong', tile: pt, meldIndex: melds.indexOf(meld) });
    }
  }

  return options;
}

// ======================== è®¡åˆ†ç³»ç»Ÿ ========================

/**
 * è®¡ç®—èƒ¡ç‰Œç•ªæ•°
 * @param {Object} winInfo - èƒ¡ç‰Œç±»å‹
 * @param {number[]} hand - æ‰‹ç‰Œ
 * @param {Object[]} melds - å…¬å¼€ç‰Œç»„
 * @param {boolean} isSelfDraw - æ˜¯å¦è‡ªæ‘¸
 * @param {boolean} isDealer - æ˜¯å¦åº„å®¶
 * @param {number} playerWind - åº§ä½é£ï¼ˆ41-44ï¼‰
 * @returns {Object} { fan, details, score }
 */
function calculateScore(winInfo, hand, melds, isSelfDraw, isDealer, seatWindTile) {
  let fan = 0;
  const details = [];

  if (winInfo.type === 'sevenPairs') {
    fan += 2;
    details.push('ä¸ƒå¯¹(2ç•ª)');
  } else if (winInfo.type === 'thirteenOrphans') {
    fan += 8;
    details.push('åä¸‰å¹º(8ç•ª)');
  } else {
    // æ ‡å‡†èƒ¡ç‰Œåˆ†æ
    const allTiles = [...hand, ...melds.flatMap(m => m.tiles)];

    // å¹³èƒ¡ï¼šå…¨é¡ºå­ï¼Œæ— ç¢°/æ 
    if (melds.length === 0 || melds.every(m => m.type === 'chi')) {
      if (isPingHu(hand, melds)) { fan += 1; details.push('å¹³èƒ¡(1ç•ª)'); }
    }

    // ç¢°ç¢°èƒ¡ï¼šå…¨åˆ»å­+æ 
    if (isPongPongHu(hand, melds)) { fan += 2; details.push('ç¢°ç¢°èƒ¡(2ç•ª)'); }

    // æ¸…ä¸€è‰²ï¼šæ‰‹ç‰Œ+å…¬å¼€ç‰Œç»„å…¨æ˜¯åŒä¸€èŠ±è‰²
    if (isQingYiSe(allTiles)) { fan += 3; details.push('æ¸…ä¸€è‰²(3ç•ª)'); }

    // æ··ä¸€è‰²ï¼šåªæœ‰ä¸€ç§èŠ±è‰²+å­—ç‰Œ
    else if (isHunYiSe(allTiles)) { fan += 1; details.push('æ··ä¸€è‰²(1ç•ª)'); }

    // é—¨å‰æ¸…ï¼šæ— åƒ/ç¢°/æ 
    if (melds.length === 0) { fan += 1; details.push('é—¨æ¸…(1ç•ª)'); }

    // å¯¹å¯¹èƒ¡å…œåº•
    if (fan === 0) fan = 1;
  }

  // è‡ªæ‘¸åŠ ç•ª
  if (isSelfDraw) { fan += 1; details.push('è‡ªæ‘¸(+1ç•ª)'); }

  // åº„å®¶ç¿»å€
  let score = fan;
  if (isDealer) {
    score *= 2;
    details.push('åº„å®¶Ã—2');
  }

  return { fan, score, details };
}

function isPingHu(hand, melds) {
  // å¹³èƒ¡ï¼š4ç»„é¡ºå­+1å°†ï¼Œä¸”æ— å…¬å¼€åˆ»å­
  if (melds.some(m => m.type === 'pong' || m.type === 'kong' || m.type === 'anKong')) return false;
  // æ£€æŸ¥æ‰‹ç‰Œèƒ½å¦å…¨éƒ¨ç”¨é¡ºå­+å°†ç»„æˆ
  return checkPingHuRecursive([...hand], 4 - melds.length);
}

function checkPingHuRecursive(tiles, needSeqs) {
  if (needSeqs === 0) {
    return tiles.length === 2 && tiles[0] === tiles[1];
  }
  const sorted = [...tiles].sort((a, b) => a - b);
  const first = sorted[0];

  // å°è¯•ä»¥firsté…å¯¹ä½œå°†ï¼Œå‰©ä½™å…¨æ˜¯é¡ºå­
  const copy = [...sorted];
  const firstIdx = copy.indexOf(first);
  const pairIdx = copy.indexOf(first, firstIdx + 1);
  if (pairIdx !== -1) {
    const rem = [...copy];
    rem.splice(pairIdx, 1); rem.splice(firstIdx, 1);
    if (canFormAllSequences(rem, needSeqs)) return true;
  }

  // ä»¥firstå¼€å§‹é¡ºå­
  if (first < 40) {
    const suit = Math.floor(first / 10);
    const rank = first % 10;
    if (rank <= 7) {
      const b = suit * 10 + rank + 1;
      const c = suit * 10 + rank + 2;
      const copy2 = [...sorted];
      const bi = copy2.indexOf(b);
      const ci = copy2.indexOf(c);
      if (bi !== -1 && ci !== -1) {
        copy2.splice(ci, 1); copy2.splice(bi, 1); copy2.splice(copy2.indexOf(first), 1);
        if (checkPingHuRecursive(copy2, needSeqs - 1)) return true;
      }
    }
  }
  return false;
}

function canFormAllSequences(tiles, count) {
  if (count === 0) return tiles.length === 0;
  if (tiles.length < 3) return false;
  const sorted = [...tiles].sort((a, b) => a - b);
  const first = sorted[0];
  if (first >= 40) return false;
  const suit = Math.floor(first / 10);
  const rank = first % 10;
  if (rank > 7) return false;
  const b = suit * 10 + rank + 1;
  const c = suit * 10 + rank + 2;
  const bi = sorted.indexOf(b);
  const ci = sorted.indexOf(c);
  if (bi === -1 || ci === -1) return false;
  sorted.splice(ci, 1); sorted.splice(bi, 1); sorted.splice(sorted.indexOf(first), 1);
  return canFormAllSequences(sorted, count - 1);
}

function isPongPongHu(hand, melds) {
  // ç¢°ç¢°èƒ¡ï¼šæ‰€æœ‰é¢å­å…¨æ˜¯åˆ»å­/æ 
  const nonPong = melds.filter(m => m.type === 'chi');
  if (nonPong.length > 0) return false;
  // æ‰‹ç‰Œä¸­çš„é¢å­ä¹Ÿå¿…é¡»å…¨æ˜¯åˆ»å­
  return canFormAllTriplets([...hand], 4 - melds.length);
}

function canFormAllTriplets(tiles, count) {
  if (count === 0) return tiles.length === 2 && tiles[0] === tiles[1];
  if (tiles.length < 3) return false;
  const sorted = [...tiles].sort((a, b) => a - b);
  const first = sorted[0];
  const c1 = sorted.indexOf(first);
  const c2 = sorted.indexOf(first, c1 + 1);
  const c3 = sorted.indexOf(first, c2 + 1);
  if (c3 === -1) return false;
  sorted.splice(c3, 1); sorted.splice(c2, 1); sorted.splice(c1, 1);
  return canFormAllTriplets(sorted, count - 1);
}

function isQingYiSe(tiles) {
  if (tiles.some(t => t >= 40)) return false; // å«å­—ç‰Œ
  const suits = new Set(tiles.map(t => Math.floor(t / 10)));
  return suits.size === 1;
}

function isHunYiSe(tiles) {
  const numbered = tiles.filter(t => t < 40);
  if (numbered.length === 0) return false;
  const suits = new Set(numbered.map(t => Math.floor(t / 10)));
  return suits.size === 1; // åªæœ‰ä¸€ç§æ•°å­—èŠ±è‰²ï¼ˆå…è®¸æœ‰å­—ç‰Œï¼‰
}

// ======================== å·¥å…·å‡½æ•° ========================

/** ç»Ÿè®¡ç‰Œçš„æ•°é‡ */
function countTiles(tiles) {
  const counts = {};
  for (const t of tiles) counts[t] = (counts[t] || 0) + 1;
  return counts;
}

/** ä»æ‰‹ç‰Œä¸­ç§»é™¤æŒ‡å®šç‰Œ */
function removeTile(hand, tile) {
  const idx = hand.indexOf(tile);
  if (idx !== -1) hand.splice(idx, 1);
}

/** æ·±æ‹·è´ */
function deepCopy(obj) { return JSON.parse(JSON.stringify(obj)); }

// ======================== AI é€»è¾‘ ========================

/**
 * AIå†³ç­–ï¼šé€‰æ‹©è¦æ‰“å‡ºçš„ç‰Œ
 * ç­–ç•¥ï¼š
 * 1. è‹¥æ¥è¿‘å¬ç‰Œï¼Œä¿ç•™æœ‰ç”¨ç‰Œ
 * 2. ä¼˜å…ˆæ‰“å­¤å¼ ï¼ˆæ— æ­å­çš„ç‰Œï¼‰
 * 3. ä¼˜å…ˆæ‰“å­—ç‰Œå­¤å¼ 
 */
function aiChooseDiscard(hand, melds) {
  const handCopy = [...hand];

  // è®¡ç®—æ¯å¼ ç‰Œçš„ä¿ç•™ä»·å€¼ï¼ˆè¶Šä½è¶Šåº”è¯¥æ‰“ï¼‰
  const scores = handCopy.map((tile, idx) => {
    const testHand = handCopy.filter((_, i) => i !== idx);
    return { tile, idx, value: getTileKeepValue(tile, testHand) };
  });

  // æŒ‰ä»·å€¼å‡åºï¼Œæ‰“æœ€æ²¡ç”¨çš„ç‰Œ
  scores.sort((a, b) => a.value - b.value);
  return scores[0].idx;
}

/**
 * è®¡ç®—ä¿ç•™æŸå¼ ç‰Œçš„ä»·å€¼
 * è€ƒè™‘ï¼šè¯¥ç‰Œèƒ½å‚ä¸å¤šå°‘ç»„åˆ
 */
function getTileKeepValue(tile, restHand) {
  let value = 0;
  const all = [...restHand, tile];
  const counts = countTiles(all);

  // è‡ªèº«æœ‰å¤šå¼ =åˆ»å­æ½œåŠ›
  const self = counts[tile] || 0;
  if (self >= 3) value += 10;
  else if (self >= 2) value += 6;
  else value += 1;

  // é¡ºå­æ­å­
  if (tile < 40) {
    const suit = Math.floor(tile / 10);
    const rank = tile % 10;
    // æ£€æŸ¥ç›¸é‚»ç‰Œæ˜¯å¦å­˜åœ¨
    const adj = [-2, -1, 1, 2].map(d => suit * 10 + rank + d).filter(t => t > suit * 10 && t <= suit * 10 + 9);
    for (const a of adj) {
      if (restHand.indexOf(a) !== -1) value += 3;
    }
  }

  // å­—ç‰Œå­¤å¼ ä»·å€¼ä½
  if (tile >= 40 && self === 1) value = 0;

  return value;
}

/**
 * AIå†³å®šæ˜¯å¦åƒ/ç¢°/æ 
 * è¿”å› 'pass'|'chi'|'pong'|'kong'|'win'
 */
function aiDecideAction(playerIdx, tile, fromPlayer) {
  const player = G.players[playerIdx];
  const hand = player.hand;

  // å…ˆæ£€æŸ¥èƒ½å¦èƒ¡
  const testHand = [...hand, tile];
  if (checkWin(testHand, player.melds)) return 'win';

  // æ£€æŸ¥èƒ½å¦æ ï¼ˆæ˜æ ï¼šæ‰‹é‡Œ3å¼ +åˆ«äººæ‰“å‡º1å¼ =4å¼ ï¼‰
  if (canKong(hand, tile)) {
    return 'kong'; // AIé‡åˆ°å¯æ ä¼˜å…ˆé€‰æ‹©æ 
  }

  // æ£€æŸ¥èƒ½å¦ç¢°
  if (canPong(hand, tile)) {
    // ç¢°åéœ€è¦æ‰“ä¸€å¼ ç‰Œï¼Œåˆ¤æ–­æ˜¯å¦åˆç®—
    const dupCount = hand.filter(t => t === tile).length;
    if (dupCount >= 2) {
      // å­—ç‰Œç¢°ä»·å€¼é«˜
      if (tile >= 40) return 'pong';
      // æ•°ç‰Œç¢°éœ€åˆ¤æ–­æ•´ä½“ç‰Œå‹
      return 'pong'; // ç®€åŒ–ç­–ç•¥
    }
  }

  // æ£€æŸ¥èƒ½å¦åƒï¼ˆåªæœ‰ä¸Šå®¶æ‰èƒ½åƒï¼‰
  const upPlayer = (playerIdx + 3) % 4; // ä¸Šå®¶æ˜¯å·¦è¾¹ä¸€ä½
  if (fromPlayer === upPlayer) {
    const chiOpts = getChiOptions(hand, tile);
    if (chiOpts.length > 0) {
      // åƒç‰Œåæ•´ä½“ç‰Œå‹æ˜¯å¦æ”¹å–„ï¼ˆç®€å•åˆ¤æ–­ï¼‰
      return 'chi_0'; // é»˜è®¤é€‰ç¬¬ä¸€ç§åƒæ³•
    }
  }

  return 'pass';
}

// ======================== æ¸¸æˆæµç¨‹ ========================

/** åˆå§‹åŒ–æ–°ä¸€å±€ */
function initGame() {
  G.wall = createWall();
  initPlayers();
  // é‡ç½®æ‰€æœ‰ç©å®¶åº„å®¶æ ‡è®°ï¼Œå†è®¾ç½®å½“å±€åº„å®¶
  G.players.forEach(p => p.isDealer = false);
  G.players[G.dealer].isDealer = true;
  G.current = G.dealer;
  G.lastDiscard = null;
  G.lastDiscardPlayer = -1;
  G.pendingAction = null;
  G.selectedTile = -1;
  G.newDrawIndex = -1;
  G.tenpaiTiles = [];
  dealHands();
  G.phase = 'discard'; // åº„å®¶å…ˆæ‰“ç‰Œ
  renderAll();
  updateTenpai();

  // å¦‚æœåº„å®¶æ˜¯AIï¼Œè§¦å‘AIå›åˆ
  if (!G.players[G.dealer].isHuman) {
    scheduleAI();
  } else {
    showActionPanel();
  }
}

/** æ‘¸ç‰Œ */
function drawTile(playerIdx) {
  if (G.wall.length === 0) {
    endRound('è’ç‰Œ', null);
    return false;
  }
  const tile = G.wall.shift();
  G.players[playerIdx].hand.push(tile);
  G.newDrawIndex = G.players[playerIdx].hand.length - 1;
  G.phase = 'discard';
  return tile;
}

/** æ‰“ç‰Œ */
function discardTile(playerIdx, handIdx) {
  const player = G.players[playerIdx];
  const tile = player.hand[handIdx];
  player.hand.splice(handIdx, 1);
  player.discards.push(tile);
  G.lastDiscard = tile;
  G.lastDiscardPlayer = playerIdx;
  G.newDrawIndex = -1;
  G.phase = 'reaction'; // ç­‰å¾…å…¶ä»–ç©å®¶ååº”
  renderAll();
  // æ£€æŸ¥å…¶ä»–ç©å®¶æ˜¯å¦æœ‰ååº”ï¼ˆèƒ¡/ç¢°/æ /åƒï¼‰
  checkReactions(playerIdx, tile);
}

/**
 * æ£€æŸ¥å…¶ä»–ç©å®¶å¯¹å¼ƒç‰Œçš„ååº”
 * ä¼˜å…ˆçº§ï¼šèƒ¡ > æ  > ç¢° > åƒ
 */
function checkReactions(fromPlayer, tile) {
  // ç©å®¶ï¼ˆç´¢å¼•0ï¼‰çš„ååº”æ£€æŸ¥
  const humanPlayer = G.players[0];
  const humanActions = [];

  if (fromPlayer !== 0) {
    const testHand = [...humanPlayer.hand, tile];
    if (checkWin(testHand, humanPlayer.melds)) humanActions.push('win');
    if (canKong(humanPlayer.hand, tile)) humanActions.push('kong');
    if (canPong(humanPlayer.hand, tile)) humanActions.push('pong');
    // åƒç‰Œï¼šåªèƒ½åƒä¸Šå®¶
    const upPlayer = (0 + 3) % 4;
    if (fromPlayer === upPlayer) {
      const chiOpts = getChiOptions(humanPlayer.hand, tile);
      if (chiOpts.length > 0) humanActions.push('chi');
    }
  }

  if (humanActions.length > 0) {
    // ç©å®¶æœ‰æ“ä½œé€‰é¡¹ï¼Œç­‰å¾…ç©å®¶é€‰æ‹©
    G.pendingAction = { fromPlayer, tile, humanActions };
    showReactionButtons(humanActions, tile);
    return;
  }

  // ç©å®¶æ— ååº”ï¼ŒAIå¤„ç†
  processAIReactions(fromPlayer, tile, 0);
}

/** AIä¾æ¬¡æ£€æŸ¥ååº” */
function processAIReactions(fromPlayer, tile, checkFrom) {
  // æŒ‰ç…§ä¼˜å…ˆçº§æ£€æŸ¥æ¯ä¸ªAIç©å®¶
  // ä¼˜å…ˆçº§ï¼šèƒ¡ > æ  > ç¢° > åƒ
  let winPlayer = -1;
  let kongPlayer = -1;
  let pongPlayer = -1;
  let chiPlayer = -1;
  let chiOption = null;

  for (let i = 1; i <= 3; i++) {
    const pi = (checkFrom + i) % 4;
    if (pi === fromPlayer) continue;
    const p = G.players[pi];
    const testHand = [...p.hand, tile];

    if (checkWin(testHand, p.melds)) { winPlayer = pi; break; }
    if (winPlayer === -1 && canKong(p.hand, tile) && kongPlayer === -1) kongPlayer = pi;
    if (winPlayer === -1 && canPong(p.hand, tile) && pongPlayer === -1) pongPlayer = pi;
  }

  // åƒç‰Œï¼ˆåªæœ‰fromPlayerçš„ä¸‹å®¶èƒ½åƒï¼‰
  const downPlayer = (fromPlayer + 1) % 4;
  if (downPlayer !== 0 && winPlayer === -1 && pongPlayer === -1 && kongPlayer === -1) {
    const chiOpts = getChiOptions(G.players[downPlayer].hand, tile);
    if (chiOpts.length > 0) { chiPlayer = downPlayer; chiOption = chiOpts[0]; }
  }

  setTimeout(() => {
    if (winPlayer !== -1) {
      performAIWin(winPlayer, tile, fromPlayer);
    } else if (kongPlayer !== -1) {
      performKong(kongPlayer, tile, fromPlayer);
    } else if (pongPlayer !== -1) {
      performPong(pongPlayer, tile);
    } else if (chiPlayer !== -1) {
      performChi(chiPlayer, tile, chiOption);
    } else {
      // æ— äººååº”ï¼Œè¿›å…¥ä¸‹ä¸€å®¶çš„æ‘¸ç‰Œ
      nextTurn(fromPlayer);
    }
  }, 600);
}

/** AIèƒ¡ç‰Œ */
function performAIWin(playerIdx, tile, fromPlayer) {
  const p = G.players[playerIdx];
  p.hand.push(tile);
  const isSelfDraw = false;
  endRound('ron', { winner: playerIdx, loser: fromPlayer, isSelfDraw });
}

/** æ‰§è¡Œç¢°ç‰Œ */
function performPong(playerIdx, tile) {
  const p = G.players[playerIdx];
  removeTile(p.hand, tile);
  removeTile(p.hand, tile);
  p.melds.push({ type: 'pong', tiles: [tile, tile, tile] });
  G.current = playerIdx;
  G.phase = 'discard';
  renderAll();
  showLog(`${p.name} ç¢°äº† ${TILE_NAMES[tile]}`);
  if (p.isHuman) {
    showActionPanel();
    updateTenpai();
  } else {
    scheduleAI();
  }
}

/** æ‰§è¡Œåƒç‰Œ */
function performChi(playerIdx, tile, combo) {
  const p = G.players[playerIdx];
  // ä»æ‰‹ç‰Œä¸­ç§»é™¤åƒçš„ä¸¤å¼ ç‰Œ
  for (const t of combo) {
    if (t !== tile) removeTile(p.hand, t);
  }
  p.melds.push({ type: 'chi', tiles: combo.sort((a, b) => a - b) });
  G.current = playerIdx;
  G.phase = 'discard';
  renderAll();
  showLog(`${p.name} åƒäº† ${TILE_NAMES[tile]}`);
  if (p.isHuman) {
    showActionPanel();
    updateTenpai();
  } else {
    scheduleAI();
  }
}

/** æ‰§è¡Œæ ç‰Œ */
function performKong(playerIdx, tile, fromPlayer) {
  const p = G.players[playerIdx];
  // æ˜æ ï¼šç§»é™¤æ‰‹ç‰Œä¸­3å¼ 
  removeTile(p.hand, tile);
  removeTile(p.hand, tile);
  removeTile(p.hand, tile);
  p.melds.push({ type: 'kong', tiles: [tile, tile, tile, tile] });
  // æ åè¡¥ç‰Œ
  const drawResult = drawTile(playerIdx);
  G.current = playerIdx;
  G.phase = 'discard';
  renderAll();
  showLog(`${p.name} æ äº† ${TILE_NAMES[tile]}`);
  if (p.isHuman) {
    // æ£€æŸ¥è‡ªæ‘¸
    const winInfo = checkWin([...p.hand], p.melds);
    showActionPanel(winInfo ? ['win'] : []);
    updateTenpai();
  } else {
    scheduleAI();
  }
}

/** ä¸‹ä¸€ä¸ªç©å®¶æ‘¸ç‰Œ */
function nextTurn(fromPlayer) {
  const next = (fromPlayer + 1) % 4;
  G.current = next;
  const tile = drawTile(next);
  if (tile === false) return; // è’ç‰Œ

  const p = G.players[next];
  sortHand(p.hand);
  // æ’åºåæ‰¾æ–°ç‰Œä½ç½®ï¼ˆå–æœ€åä¸€ä¸ªç›¸åŒå€¼çš„ä¸‹æ ‡ï¼Œè¿‘ä¼¼"æ–°æ‘¸"ï¼‰
  let ndi = 0;
  for (let i = p.hand.length - 1; i >= 0; i--) {
    if (p.hand[i] === tile) { ndi = i; break; }
  }
  G.newDrawIndex = ndi;

  // æ£€æŸ¥è‡ªæ‘¸
  const winInfo = checkWin([...p.hand], p.melds);

  renderAll();

  if (p.isHuman) {
    // æ£€æŸ¥æš—æ /åŠ æ 
    const kongOpts = getSelfKongOptions(p.hand, p.melds);
    const extraBtns = [];
    if (winInfo) extraBtns.push('win');
    if (kongOpts.length > 0) extraBtns.push('selfKong');
    showActionPanel(extraBtns);
    updateTenpai();
  } else {
    // AIè‡ªæ‘¸æ£€æµ‹
    if (winInfo) {
      setTimeout(() => endRound('zimo', { winner: next, isSelfDraw: true }), 800);
    } else {
      scheduleAI();
    }
  }
}

/** å®‰æ’AIæ“ä½œï¼ˆå»¶è¿Ÿä»¥æ¨¡æ‹Ÿæ€è€ƒï¼‰*/
function scheduleAI() {
  const p = G.players[G.current];
  document.getElementById(`area-${posName(G.current)}`).classList.add('thinking-active');

  if (G.aiTimer) clearTimeout(G.aiTimer);
  G.aiTimer = setTimeout(() => {
    document.getElementById(`area-${posName(G.current)}`).classList.remove('thinking-active');
    aiTakeTurn(G.current);
  }, 800 + Math.random() * 600);
}

/** AIæ‰§è¡Œå›åˆ */
function aiTakeTurn(playerIdx) {
  const p = G.players[playerIdx];
  if (G.phase !== 'discard') return;

  // æ£€æŸ¥æš—æ /åŠ æ 
  const kongOpts = getSelfKongOptions(p.hand, p.melds);
  if (kongOpts.length > 0 && Math.random() > 0.3) {
    const opt = kongOpts[0];
    if (opt.type === 'anKong') {
      // æš—æ 
      const tile = opt.tile;
      p.hand = p.hand.filter(t => t !== tile);
      p.melds.push({ type: 'anKong', tiles: [tile, tile, tile, tile] });
      drawTile(playerIdx);
      renderAll();
      showLog(`${p.name} æš—æ äº†`);
      scheduleAI();
      return;
    }
  }

  // é€‰æ‹©æ‰“ç‰Œ
  const discardIdx = aiChooseDiscard(p.hand, p.melds);
  discardTile(playerIdx, discardIdx);
}

/** ç»“æŸæœ¬å±€ */
function endRound(reason, info) {
  G.phase = 'end';
  if (G.aiTimer) clearTimeout(G.aiTimer);

  let title = '', content = '', scoreChange = [0, 0, 0, 0];

  if (reason === 'zimo' || reason === 'ron') {
    const winner = info.winner;
    const p = G.players[winner];
    const winInfo = checkWin([...p.hand], p.melds);
    const isSelfDraw = info.isSelfDraw;
    const scoreInfo = calculateScore(
      winInfo, p.hand, p.melds, isSelfDraw,
      p.isDealer, SEAT_WINDS.indexOf(p.wind)
    );

    title = isSelfDraw ? 'ğŸ€„ è‡ªæ‘¸ï¼' : 'ğŸ€„ èƒ¡ç‰Œï¼';

    if (isSelfDraw) {
      // è‡ªæ‘¸ï¼šå…¶ä½™æ¯äººä»˜scoreInfo.scoreåˆ†
      for (let i = 0; i < 4; i++) {
        if (i !== winner) scoreChange[i] = -scoreInfo.score;
      }
      scoreChange[winner] = scoreInfo.score * 3;
    } else {
      // ç‚¹ç‚®ï¼šåªæœ‰æ”¾ç‚®è€…ä»˜åˆ†
      const loser = info.loser;
      scoreChange[winner] = scoreInfo.score * 4;
      scoreChange[loser] = -scoreInfo.score * 4;
    }

    content = `${p.name}ï¼š${winInfo.name}\n${scoreInfo.details.join(' + ')}\nå…± ${scoreInfo.fan} ç•ª (${scoreInfo.score * (isSelfDraw ? 3 : 4)}åˆ†)`;
  } else if (reason === 'è’ç‰Œ') {
    title = 'è’ç‰Œ';
    content = 'ç‰Œå¢™æ‘¸å®Œï¼Œæµå±€é‡æ¥';
  }

  // æ›´æ–°ç§¯åˆ†
  for (let i = 0; i < 4; i++) {
    G.scores[i] += scoreChange[i];
  }

  showMessage(title, content, [
    { text: 'å†æ¥ä¸€å±€', cls: 'btn-primary', action: startNewRound },
    { text: 'æŸ¥çœ‹æ‰‹ç‰Œ', cls: 'btn-secondary', action: () => hideMessage() }
  ]);

  renderAll();
  renderScores();
}

function startNewRound() {
  hideMessage();
  // èµ¢å®¶æˆ–ä¸‹ä¸€ä½ä½œåº„
  G.dealer = (G.dealer + 1) % 4;
  G.roundCount++;
  renderScores();
  initGame();
}

// ======================== ç©å®¶æ“ä½œå¤„ç† ========================

/** ç©å®¶ç‚¹å‡»æ‰‹ç‰Œ */
function onPlayerTileClick(idx) {
  if (G.phase !== 'discard' || G.current !== 0) return;

  if (G.selectedTile === idx) {
    // äºŒæ¬¡ç‚¹å‡»ç¡®è®¤æ‰“ç‰Œ
    discardTile(0, idx);
    G.selectedTile = -1;
  } else {
    G.selectedTile = idx;
    renderPlayerHand();
    showActionPanel();
  }
}

/** ç©å®¶ç¡®è®¤æ‰“ç‰Œ */
function onConfirmDiscard() {
  if (G.selectedTile === -1) return;
  discardTile(0, G.selectedTile);
  G.selectedTile = -1;
}

/** ç©å®¶ååº”æŒ‰é’® */
function onPlayerAction(action) {
  if (!G.pendingAction) return;
  const { fromPlayer, tile } = G.pendingAction;
  const p = G.players[0];

  hideReactionButtons();

  if (action === 'win') {
    p.hand.push(tile);
    endRound('ron', { winner: 0, loser: fromPlayer, isSelfDraw: false });
  } else if (action === 'pong') {
    performPong(0, tile);
  } else if (action === 'kong') {
    performKong(0, tile, fromPlayer);
  } else if (action === 'chi') {
    const chiOpts = getChiOptions(p.hand, tile);
    if (chiOpts.length === 1) {
      performChi(0, tile, chiOpts[0]);
    } else {
      // å¤šç§åƒæ³•ï¼Œè®©ç©å®¶é€‰æ‹©
      showChiOptions(chiOpts, tile);
      return;
    }
  } else {
    // è¿‡
    G.pendingAction = null;
    processAIReactions(fromPlayer, tile, 0);
  }

  G.pendingAction = null;
}

/** ç©å®¶è‡ªæ‘¸/æš—æ  */
function onSelfAction(action) {
  const p = G.players[0];
  if (action === 'win') {
    const winInfo = checkWin([...p.hand], p.melds);
    if (winInfo) endRound('zimo', { winner: 0, isSelfDraw: true });
  } else if (action === 'selfKong') {
    const opts = getSelfKongOptions(p.hand, p.melds);
    if (opts.length > 0) {
      const opt = opts[0];
      const tile = opt.tile;
      if (opt.type === 'anKong') {
        p.hand = p.hand.filter(t => t !== tile);
        p.melds.push({ type: 'anKong', tiles: [tile, tile, tile, tile] });
        drawTile(0);
        sortHand(p.hand);
        renderAll();
        showLog(`ä½ æš—æ äº† ${TILE_NAMES[tile]}`);
        const winAfterKong = checkWin([...p.hand], p.melds);
        showActionPanel(winAfterKong ? ['win'] : []);
        updateTenpai();
      } else if (opt.type === 'addKong') {
        removeTile(p.hand, tile);
        const meld = p.melds[opt.meldIndex];
        meld.type = 'addKong';
        meld.tiles.push(tile);
        drawTile(0);
        sortHand(p.hand);
        renderAll();
        showLog(`ä½ åŠ æ äº† ${TILE_NAMES[tile]}`);
        const winAfterAddKong = checkWin([...p.hand], p.melds);
        showActionPanel(winAfterAddKong ? ['win'] : []);
        updateTenpai();
      }
    }
  }
}

// ======================== æ¸²æŸ“ç³»ç»Ÿ ========================

/** è·å–ä½ç½®åç§° */
function posName(idx) {
  return ['bottom', 'left', 'top', 'right'][idx];
}

/** æ¸²æŸ“å•å¼ ç‰Œ */
function createTileEl(tile, opts = {}) {
  const div = document.createElement('div');
  div.className = 'tile';

  if (opts.back) {
    div.classList.add('back');
    return div;
  }

  const suit = tile >= 40 ? 4 : Math.floor(tile / 10);
  const rank = tile % 10;
  div.classList.add(SUIT_NAME[suit]);

  if (opts.selected) div.classList.add('selected');
  if (opts.hint) div.classList.add('hint');
  if (opts.winHint) div.classList.add('win-hint');
  if (opts.newDraw) div.classList.add('new-draw');
  if (opts.lastDiscard) div.classList.add('last-discard');

  const rankEl = document.createElement('div');
  rankEl.className = 'rank';
  const suitEl = document.createElement('div');
  suitEl.className = 'suit';

  if (tile >= 40) {
    rankEl.textContent = TILE_NAMES[tile];
  } else {
    const rankChars = ['','ä¸€','äºŒ','ä¸‰','å››','äº”','å…­','ä¸ƒ','å…«','ä¹'];
    const suitChars = {1:'ä¸‡', 2:'ç­’', 3:'æ¡'};
    rankEl.textContent = rankChars[rank];
    suitEl.textContent = suitChars[suit];
  }

  div.appendChild(rankEl);
  if (tile < 40) div.appendChild(suitEl);

  if (opts.onClick) div.addEventListener('click', opts.onClick);

  return div;
}

/** æ¸²æŸ“ç©å®¶æ‰‹ç‰Œï¼ˆäººç±»ç©å®¶ï¼‰*/
function renderPlayerHand() {
  const p = G.players[0];
  const container = document.getElementById('my-hand-area');
  container.innerHTML = '';

  const tenpaiSet = new Set(G.tenpaiTiles);
  const kongOpts = getSelfKongOptions(p.hand, p.melds);
  const kongTiles = new Set(kongOpts.map(o => o.tile));

  p.hand.forEach((tile, idx) => {
    const isSelected = G.selectedTile === idx;
    const isNewDraw = idx === G.newDrawIndex;
    const isWinHint = tenpaiSet.size > 0 && G.tenpaiTiles.length > 0;

    // æ‰“å‡ºè¿™å¼ ç‰Œåæ˜¯å¦å¬ç‰Œ
    const testHand = p.hand.filter((_, i) => i !== idx);
    const tenpaiAfter = getTenpaiTiles(testHand, p.melds);

    const el = createTileEl(tile, {
      selected: isSelected,
      newDraw: isNewDraw,
      hint: tenpaiAfter.length > 0,
      winHint: checkWin([...p.hand], p.melds) !== null && isNewDraw,
      onClick: () => onPlayerTileClick(idx)
    });

    // åŠ ä¸€ä¸ªåˆ†éš”ç¬¦åŒºåˆ†æ–°æ‘¸çš„ç‰Œ
    if (idx === G.newDrawIndex && idx > 0) {
      const sep = document.createElement('div');
      sep.style.cssText = 'width:4px;height:100%;border-left:1px dashed rgba(255,255,255,0.3);flex-shrink:0';
      container.appendChild(sep);
    }

    container.appendChild(el);
  });
}

/** æ¸²æŸ“AIæ‰‹ç‰Œ */
function renderAIHand(playerIdx) {
  const p = G.players[playerIdx];
  const pos = posName(playerIdx);
  const container = document.getElementById(`hand-${pos}`);
  if (!container) return;
  container.innerHTML = '';

  p.hand.forEach(() => {
    container.appendChild(createTileEl(0, { back: true }));
  });
}

/** æ¸²æŸ“å…¬å¼€ç‰Œç»„ */
function renderMelds(playerIdx) {
  const p = G.players[playerIdx];
  const pos = posName(playerIdx);
  const container = document.getElementById(`melds-${pos}`);
  if (!container) return;
  container.innerHTML = '';

  for (const meld of p.melds) {
    const group = document.createElement('div');
    group.className = 'meld-group';
    const tilesToShow = meld.type === 'anKong'
      ? [null, meld.tiles[1], meld.tiles[2], null] // æš—æ ä¸­é—´ä¸¤å¼ æ­£é¢
      : meld.tiles;

    tilesToShow.forEach(tile => {
      if (tile === null) {
        group.appendChild(createTileEl(0, { back: true }));
      } else {
        group.appendChild(createTileEl(tile));
      }
    });
    container.appendChild(group);
  }
}

/** æ¸²æŸ“å¼ƒç‰ŒåŒº */
function renderDiscards() {
  const positions = ['bottom', 'left', 'top', 'right'];
  const discIds = ['disc-bottom', 'disc-left', 'disc-top', 'disc-right'];

  positions.forEach((pos, idx) => {
    const container = document.getElementById(discIds[idx]);
    if (!container) return;
    container.innerHTML = '';

    const p = G.players[idx];
    p.discards.forEach((tile, di) => {
      const isLast = idx === G.lastDiscardPlayer && di === p.discards.length - 1;
      container.appendChild(createTileEl(tile, { lastDiscard: isLast }));
    });
  });
}

/** æ›´æ–°ä¸­å¤®ä¿¡æ¯ */
function updateCenterInfo() {
  document.getElementById('wall-count').textContent = G.wall.length;
  const windNames = {41:'ä¸œ',42:'å—',43:'è¥¿',44:'åŒ—'};
  document.getElementById('round-wind').textContent = windNames[G.roundWind] || 'ä¸œ';
  document.getElementById('dealer-name').textContent = G.players[G.dealer]?.name || '-';
  document.getElementById('current-fan').textContent = G.current >= 0 ? G.players[G.current]?.name + 'å›åˆ' : '-';
}

/** æ›´æ–°ç©å®¶æ ‡ç­¾ */
function updatePlayerLabels() {
  for (let i = 0; i < 4; i++) {
    const p = G.players[i];
    const pos = posName(i);
    const label = document.getElementById(`label-${pos}`);
    if (!label) continue;

    label.classList.toggle('active', G.current === i && G.phase === 'discard');
    label.classList.toggle('dealer', p.isDealer);

    const windEl = document.getElementById(`wind-${pos}`);
    if (windEl) windEl.textContent = p.wind;

    const nameEl = document.getElementById(`name-${pos}`);
    if (nameEl && i !== 0) nameEl.textContent = p.name;

    const scoreEl = document.getElementById(`score-${pos}`);
    if (scoreEl) scoreEl.textContent = G.scores[i];
  }
}

/** æ¸²æŸ“æ‰€æœ‰ */
function renderAll() {
  for (let i = 1; i <= 3; i++) {
    renderAIHand(i);
    renderMelds(i);
  }
  renderPlayerHand();
  renderMelds(0);
  renderDiscards();
  updateCenterInfo();
  updatePlayerLabels();
}

/** æ¸²æŸ“ç§¯åˆ†æ¿ */
function renderScores() {
  const container = document.getElementById('score-display');
  container.innerHTML = '';
  G.players.forEach((p, i) => {
    const item = document.createElement('div');
    item.className = 'score-item' + (i === 0 ? ' me' : '');
    item.textContent = `${p.name}: ${G.scores[i]}`;
    container.appendChild(item);
  });
}

// ======================== æ“ä½œæŒ‰é’® ========================

/** æ˜¾ç¤ºæ“ä½œé¢æ¿ï¼ˆæ‰“ç‰Œé˜¶æ®µï¼‰*/
function showActionPanel(extra = []) {
  const panel = document.getElementById('action-panel');
  panel.innerHTML = '';

  if (G.phase === 'discard' && G.current === 0) {
    // æ˜¾ç¤ºç¡®è®¤æ‰“ç‰ŒæŒ‰é’®ï¼ˆå¦‚æœé€‰ä¸­äº†ç‰Œï¼‰
    if (G.selectedTile !== -1) {
      addBtn(panel, `å‡º ${TILE_NAMES[G.players[0].hand[G.selectedTile]]}`, 'discard-confirm', onConfirmDiscard);
    } else {
      addBtn(panel, 'é€‰ç‰Œå‡ºç‰Œ', 'pass', null, true);
    }

    if (extra.includes('win')) {
      addBtn(panel, 'è‡ªæ‘¸', 'win', () => onSelfAction('win'));
    }
    if (extra.includes('selfKong')) {
      addBtn(panel, 'æš—æ ', 'kong', () => onSelfAction('selfKong'));
    }
  }
}

/** æ˜¾ç¤ºååº”æŒ‰é’® */
function showReactionButtons(actions, tile) {
  const panel = document.getElementById('action-panel');
  panel.innerHTML = '';

  const tileName = TILE_NAMES[tile];
  if (actions.includes('win')) addBtn(panel, `èƒ¡ ${tileName}`, 'win', () => onPlayerAction('win'));
  if (actions.includes('kong')) addBtn(panel, `æ  ${tileName}`, 'kong', () => onPlayerAction('kong'));
  if (actions.includes('pong')) addBtn(panel, `ç¢° ${tileName}`, 'pong', () => onPlayerAction('pong'));
  if (actions.includes('chi')) addBtn(panel, `åƒ ${tileName}`, 'chi', () => onPlayerAction('chi'));
  addBtn(panel, 'è¿‡', 'pass', () => onPlayerAction('pass'));
}

/** æ˜¾ç¤ºå¤šç§åƒæ³•é€‰æ‹© */
function showChiOptions(opts, claimedTile) {
  const panel = document.getElementById('action-panel');
  panel.innerHTML = '';

  opts.forEach(combo => {
    const names = combo.map(t => TILE_NAMES[t]).join('');
    addBtn(panel, `åƒ ${names}`, 'chi', () => {
      G.pendingAction = null;
      performChi(0, claimedTile, combo);
    });
  });
  addBtn(panel, 'è¿‡', 'pass', () => {
    const pa = G.pendingAction;
    G.pendingAction = null;
    hideReactionButtons();
    if (pa) processAIReactions(pa.fromPlayer, pa.tile, 0);
  });
}

function hideReactionButtons() {
  document.getElementById('action-panel').innerHTML = '';
}

function addBtn(parent, text, cls, handler, disabled = false) {
  const btn = document.createElement('button');
  btn.className = `action-btn ${cls}`;
  btn.textContent = text;
  if (disabled) { btn.style.opacity = '0.5'; btn.style.pointerEvents = 'none'; }
  else if (handler) btn.addEventListener('click', handler);
  parent.appendChild(btn);
  return btn;
}

// ======================== å¬ç‰Œæç¤º ========================

function updateTenpai() {
  if (G.current !== 0 || G.phase !== 'discard') {
    document.getElementById('tenpai-bar').style.display = 'none';
    G.tenpaiTiles = [];
    renderPlayerHand(); // åˆ·æ–°ç‰Œé¢ï¼ˆç§»é™¤æç¤ºï¼‰
    return;
  }
  const p = G.players[0];
  if (p.hand.length !== 13 && p.hand.length !== 14) {
    document.getElementById('tenpai-bar').style.display = 'none';
    return;
  }

  // è®¡ç®—æ‰“å‡ºæ¯å¼ ç‰Œåçš„å¬ç‰Œ
  let allWaiting = [];
  for (let i = 0; i < p.hand.length; i++) {
    const testHand = p.hand.filter((_, j) => j !== i);
    const waiting = getTenpaiTiles(testHand, p.melds);
    allWaiting = [...new Set([...allWaiting, ...waiting])];
  }

  G.tenpaiTiles = allWaiting;

  const bar = document.getElementById('tenpai-bar');
  if (allWaiting.length > 0) {
    bar.style.display = 'block';
    document.getElementById('tenpai-tiles').textContent =
      allWaiting.map(t => TILE_NAMES[t]).join(' ');
  } else {
    bar.style.display = 'none';
  }
}

// ======================== æ¶ˆæ¯å¼¹çª— ========================

function showMessage(title, content, buttons) {
  document.getElementById('msg-title').textContent = title;
  document.getElementById('msg-content').textContent = content;
  const btns = document.getElementById('msg-btns');
  btns.innerHTML = '';
  buttons.forEach(({ text, cls, action }) => {
    const btn = document.createElement('button');
    btn.textContent = text;
    btn.className = cls;
    btn.addEventListener('click', action);
    btns.appendChild(btn);
  });
  document.getElementById('message-overlay').classList.add('show');
}

function hideMessage() {
  document.getElementById('message-overlay').classList.remove('show');
}

// ç®€å•æ—¥å¿—ï¼ˆæ˜¾ç¤ºåœ¨ä¸­å¤®infoåŒºï¼‰
function showLog(msg) {
  document.getElementById('current-fan').textContent = msg;
  setTimeout(() => {
    if (G.current >= 0) {
      document.getElementById('current-fan').textContent = G.players[G.current].name + 'å›åˆ';
    }
  }, 2000);
}

// ======================== å¯åŠ¨æ¸¸æˆ ========================

function startGame() {
  G.dealer = 0;
  G.roundCount = 1;
  G.roundWind = 41; // ä¸œé£å±€
  G.scores = [0, 0, 0, 0];

  showMessage('ğŸ€„ éº»å°†æ¸¸æˆ', [
    'â€¢ 136å¼ æ ‡å‡†éº»å°†',
    'â€¢ æ ‡å‡†èƒ¡ç‰Œï¼š4ç»„é¢å­+1å°†',
    'â€¢ ç‰¹æ®Šç‰Œå‹ï¼šä¸ƒå¯¹ã€åä¸‰å¹º',
    'â€¢ åƒç¢°æ èƒ¡å‡æ”¯æŒ',
    'â€¢ ç»¿è‰²æç¤ºç‰Œ=æ‰“å‡ºåå¯å¬ç‰Œ',
    'â€¢ é€‰ä¸­ç‰Œå†æ¬¡ç‚¹å‡»æˆ–æŒ‰ç¡®è®¤å‡ºç‰Œ',
  ].join('\n'), [
    { text: 'å¼€å§‹æ¸¸æˆ', cls: 'btn-primary', action: () => { hideMessage(); initGame(); } }
  ]);
}

// é¡µé¢åŠ è½½å®Œæˆåå¯åŠ¨
document.addEventListener('DOMContentLoaded', () => {
  startGame();
  renderScores();
});
</script>
</body>
</html>
