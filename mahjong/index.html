<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>麻将 - Canvas 版</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; user-select: none; }
html, body { width: 100%; height: 100%; overflow: hidden; background: #1a5c2a; }
#gameCanvas { display: block; width: 100%; height: 100%; }
#rotate-tip {
  display: none; position: fixed; inset: 0; background: #1a5c2a;
  color: #fff; font-size: 20px; justify-content: center;
  align-items: center; z-index: 9999; flex-direction: column; gap: 16px;
}
#rotate-tip svg { width: 60px; height: 60px; fill: #fff; animation: rotate 2s infinite; }
@keyframes rotate { 0%,100%{transform:rotate(-90deg)} 50%{transform:rotate(90deg)} }
@media (orientation: portrait) { #rotate-tip { display: flex; } }
</style>
</head>
<body>
<canvas id="gameCanvas"></canvas>
<div id="rotate-tip">
  <svg viewBox="0 0 24 24"><path d="M16.48 2.52c3.27 1.55 5.61 4.72 5.97 8.48h1.5C23.44 4.84 20.29 1.2 16.48.02v2.5zm-6.25-.77v2.5c3.21.91 5.97 3.7 6.68 7.25h2.5c-.81-4.86-4.75-8.5-9.18-9.75zM16 10c0-2.21-1.79-4-4-4s-4 1.79-4 4 1.79 4 4 4 4-1.79 4-4zM0 16l4-4v3h12v2H4v3l-4-4z"/></svg>
  请旋转设备为横屏
</div>
<script>
// ===== 麻将游戏 Canvas 版 =====
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

// 设备像素比
const dpr = window.devicePixelRatio || 1;

// 游戏状态
const state = {
  tiles: [], // 牌墙
  players: [[], [], [], []], // 4 个玩家手牌
  discards: [], // 弃牌
  currentPlayer: 0,
  selectedTile: -1,
  currentDraw: null,
  scores: [0, 0, 0, 0],
  dealer: 0,
  gameOver: false
};

// 牌面配置
const TILE_CONFIG = {
  width: 32,
  height: 44,
  gap: 2,
  cornerRadius: 4
};

// 麻将牌定义
const TILE_TYPES = [
  // 万
  ...Array(9).fill(null).map((_, i) => ({ type: 'wan', value: String(i+1), display: ['一','二','三','四','五','六','七','八','九'][i] + '万', color: '#c0392b' })),
  // 筒
  ...Array(9).fill(null).map((_, i) => ({ type: 'tong', value: String(i+1), display: ['一','二','三','四','五','六','七','八','九'][i] + '筒', color: '#2980b9' })),
  // 条
  ...Array(9).fill(null).map((_, i) => ({ type: 'tiao', value: String(i+1), display: ['一','二','三','四','五','六','七','八','九'][i] + '条', color: '#27ae60' })),
  // 风牌
  { type: 'feng', value: '东', display: '东', color: '#2c3e50' },
  { type: 'feng', value: '南', display: '南', color: '#2c3e50' },
  { type: 'feng', value: '西', display: '西', color: '#2c3e50' },
  { type: 'feng', value: '北', display: '北', color: '#2c3e50' },
  // 箭牌
  { type: 'jian', value: '中', display: '中', color: '#c0392b' },
  { type: 'jian', value: '发', display: '发', color: '#27ae60' },
  { type: 'jian', value: '白', display: '白', color: '#2980b9' }
];

// 初始化 Canvas
function initCanvas() {
  const rect = canvas.getBoundingClientRect();
  canvas.width = rect.width * dpr;
  canvas.height = rect.height * dpr;
  ctx.scale(dpr, dpr);
  render();
}

// 创建牌墙
function createWall() {
  state.tiles = [];
  TILE_TYPES.forEach(tile => {
    for (let i = 0; i < 4; i++) {
      state.tiles.push({ ...tile, id: Math.random() });
    }
  });
  shuffle(state.tiles);
}

// 洗牌
function shuffle(array) {
  for (let i = array.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [array[i], array[j]] = [array[j], array[i]];
  }
}

// 发牌
function dealTiles() {
  state.players = [[], [], [], []];
  for (let i = 0; i < 13; i++) {
    for (let p = 0; p < 4; p++) {
      state.players[p].push(state.tiles.pop());
    }
  }
  state.currentPlayer = 0;
  state.currentDraw = null;
  state.discards = [];
  state.gameOver = false;
}

// 绘制单张牌
function drawTile(x, y, tile, selected = false, clickable = false) {
  const { width, height, cornerRadius } = TILE_CONFIG;
  
  // 牌背
  ctx.fillStyle = selected ? '#fffef0' : '#f0e8c8';
  ctx.strokeStyle = '#c8a86c';
  ctx.lineWidth = 1;
  
  // 圆角矩形
  ctx.beginPath();
  ctx.moveTo(x + cornerRadius, y);
  ctx.lineTo(x + width - cornerRadius, y);
  ctx.quadraticCurveTo(x + width, y, x + width, y + cornerRadius);
  ctx.lineTo(x + width, y + height - cornerRadius);
  ctx.quadraticCurveTo(x + width, y + height, x + width - cornerRadius, y + height);
  ctx.lineTo(x + cornerRadius, y + height);
  ctx.quadraticCurveTo(x, y + height, x, y + height - cornerRadius);
  ctx.lineTo(x, y + cornerRadius);
  ctx.quadraticCurveTo(x, y, x + cornerRadius, y);
  ctx.closePath();
  ctx.fill();
  ctx.stroke();
  
  // 阴影
  ctx.shadowColor = 'rgba(0,0,0,0.3)';
  ctx.shadowBlur = 2;
  ctx.shadowOffsetX = 1;
  ctx.shadowOffsetY = 2;
  
  // 选中效果
  if (selected) {
    ctx.shadowColor = 'rgba(255,215,0,0.6)';
    ctx.shadowBlur = 8;
    ctx.shadowOffsetY = -8;
  }
  
  // 绘制文字
  if (tile) {
    ctx.fillStyle = tile.color;
    ctx.font = 'bold 14px "Microsoft YaHei"';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    
    const centerX = x + width / 2;
    const centerY = y + height / 2;
    
    if (tile.type === 'wan' || tile.type === 'tong' || tile.type === 'tiao') {
      // 数字
      ctx.font = 'bold 16px "Microsoft YaHei"';
      ctx.fillText(tile.display[0], centerX, centerY - 6);
      // 单位
      ctx.font = '10px "Microsoft YaHei"';
      ctx.fillText(tile.display.slice(1), centerX, centerY + 8);
    } else {
      ctx.font = 'bold 16px "Microsoft YaHei"';
      ctx.fillText(tile.display, centerX, centerY);
    }
  }
  
  // 重置阴影
  ctx.shadowColor = 'transparent';
  ctx.shadowBlur = 0;
  ctx.shadowOffsetX = 0;
  ctx.shadowOffsetY = 0;
}

// 绘制牌背
function drawTileBack(x, y) {
  const { width, height, cornerRadius } = TILE_CONFIG;
  
  // 牌背底色
  const gradient = ctx.createLinearGradient(x, y, x + width, y + height);
  gradient.addColorStop(0, '#2d6e8e');
  gradient.addColorStop(1, '#1a4d6e');
  ctx.fillStyle = gradient;
  ctx.strokeStyle = '#1a3d5e';
  ctx.lineWidth = 1;
  
  // 圆角矩形
  ctx.beginPath();
  ctx.moveTo(x + cornerRadius, y);
  ctx.lineTo(x + width - cornerRadius, y);
  ctx.quadraticCurveTo(x + width, y, x + width, y + cornerRadius);
  ctx.lineTo(x + width, y + height - cornerRadius);
  ctx.quadraticCurveTo(x + width, y + height, x + width - cornerRadius, y + height);
  ctx.lineTo(x + cornerRadius, y + height);
  ctx.quadraticCurveTo(x, y + height, x, y + height - cornerRadius);
  ctx.lineTo(x, y + cornerRadius);
  ctx.quadraticCurveTo(x, y, x + cornerRadius, y);
  ctx.closePath();
  ctx.fill();
  ctx.stroke();
  
  // 花纹
  ctx.strokeStyle = 'rgba(255,255,255,0.2)';
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.moveTo(x + 3, y + 3);
  ctx.lineTo(x + width - 3, y + height - 3);
  ctx.stroke();
}

// 渲染游戏
function render() {
  const width = canvas.width / dpr;
  const height = canvas.height / dpr;
  
  // 清空画布
  ctx.fillStyle = '#1e7a38';
  ctx.fillRect(0, 0, width, height);
  
  // 绘制中央弃牌区
  ctx.fillStyle = 'rgba(0,0,0,0.2)';
  ctx.fillRect(width * 0.3, height * 0.35, width * 0.4, height * 0.3);
  ctx.strokeStyle = 'rgba(255,215,0,0.3)';
  ctx.strokeRect(width * 0.3, height * 0.35, width * 0.4, height * 0.3);
  
  // 绘制弃牌
  state.discards.forEach((tile, i) => {
    const col = i % 6;
    const row = Math.floor(i / 6);
    const x = width * 0.32 + col * (width * 0.06);
    const y = height * 0.37 + row * (height * 0.09);
    drawTile(x, y, tile, false, false);
  });
  
  // 绘制玩家区域
  drawPlayerArea(0, width, height); // 下方（自己）
  drawPlayerArea(1, width, height); // 上方（对家）
  drawPlayerArea(2, width, height); // 左侧
  drawPlayerArea(3, width, height); // 右侧
  
  // 绘制当前摸的牌
  if (state.currentDraw && state.currentPlayer === 0) {
    const x = width / 2 - TILE_CONFIG.width / 2;
    const y = height * 0.75;
    drawTile(x, y, state.currentDraw, true, true);
    
    // 文字提示
    ctx.fillStyle = '#ffd700';
    ctx.font = '12px "Microsoft YaHei"';
    ctx.textAlign = 'center';
    ctx.fillText('摸到的牌', x + TILE_CONFIG.width / 2, y + TILE_CONFIG.height + 15);
  }
  
  // 绘制按钮
  drawButtons(width, height);
  
  // 绘制信息
  drawInfo(width, height);
}

// 绘制玩家区域
function drawPlayerArea(playerIdx, width, height) {
  const hand = state.players[playerIdx];
  
  if (playerIdx === 0) {
    // 下方玩家（自己）- 横向排列
    const startX = width * 0.15;
    const y = height * 0.82;
    hand.forEach((tile, i) => {
      const x = startX + i * (TILE_CONFIG.width + TILE_CONFIG.gap);
      const selected = (i === state.selectedTile);
      drawTile(x, y, tile, selected, true);
    });
  } else if (playerIdx === 1) {
    // 上方玩家（对家）- 牌背
    const startX = width * 0.35;
    const y = height * 0.08;
    hand.forEach((_, i) => {
      const x = startX + i * (TILE_CONFIG.width * 0.7 + TILE_CONFIG.gap);
      drawTileBack(x, y);
    });
  } else if (playerIdx === 2) {
    // 左侧玩家 - 牌背竖向
    const x = width * 0.05;
    const startY = height * 0.3;
    hand.forEach((_, i) => {
      const y = startY + i * (TILE_CONFIG.width * 0.7 + TILE_CONFIG.gap);
      drawTileBack(x, y);
    });
  } else if (playerIdx === 3) {
    // 右侧玩家 - 牌背竖向
    const x = width - TILE_CONFIG.width - width * 0.05;
    const startY = height * 0.3;
    hand.forEach((_, i) => {
      const y = startY + i * (TILE_CONFIG.width * 0.7 + TILE_CONFIG.gap);
      drawTileBack(x, y);
    });
  }
}

// 绘制按钮
function drawButtons(width, height) {
  const buttons = [
    { text: '摸牌', x: width / 2 - 120, y: height * 0.92, color: '#667eea' },
    { text: '打出', x: width / 2 - 40, y: height * 0.92, color: '#f5576c' },
    { text: '胡牌', x: width / 2 + 40, y: height * 0.92, color: '#38ef7d' },
    { text: '新游戏', x: width / 2 + 120, y: height * 0.92, color: '#667eea' }
  ];
  
  buttons.forEach(btn => {
    // 按钮背景
    ctx.fillStyle = btn.color;
    ctx.fillRect(btn.x - 40, btn.y - 15, 80, 30);
    
    // 按钮文字
    ctx.fillStyle = '#fff';
    ctx.font = 'bold 14px "Microsoft YaHei"';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(btn.text, btn.x, btn.y);
  });
}

// 绘制信息
function drawInfo(width, height) {
  ctx.fillStyle = 'rgba(0,0,0,0.5)';
  ctx.fillRect(10, 10, 150, 80);
  
  ctx.fillStyle = '#fff';
  ctx.font = '12px "Microsoft YaHei"';
  ctx.textAlign = 'left';
  ctx.fillText(`剩余牌：${state.tiles.length}`, 20, 30);
  ctx.fillText(`已打：${state.discards.length}`, 20, 50);
  ctx.fillText(`当前：${['你', '电脑 1', '电脑 2', '电脑 3'][state.currentPlayer]}`, 20, 70);
}

// 触摸事件
canvas.addEventListener('click', (e) => {
  const rect = canvas.getBoundingClientRect();
  const x = (e.clientX - rect.left) * dpr;
  const y = (e.clientY - rect.top) * dpr;
  
  const width = canvas.width / dpr;
  const height = canvas.height / dpr;
  
  // 检查按钮点击
  checkButtonClick(x, y, width, height);
  
  // 检查手牌点击
  if (state.currentPlayer === 0) {
    const startX = width * 0.15;
    const handY = height * 0.82;
    const hand = state.players[0];
    
    for (let i = 0; i < hand.length; i++) {
      const tileX = startX + i * (TILE_CONFIG.width + TILE_CONFIG.gap);
      if (x >= tileX && x <= tileX + TILE_CONFIG.width &&
          y >= handY && y <= handY + TILE_CONFIG.height) {
        state.selectedTile = i;
        render();
        break;
      }
    }
  }
});

// 检查按钮点击
function checkButtonClick(x, y, width, height) {
  const buttons = [
    { action: 'draw', x: width / 2 - 120, y: height * 0.92 },
    { action: 'play', x: width / 2 - 40, y: height * 0.92 },
    { action: 'win', x: width / 2 + 40, y: height * 0.92 },
    { action: 'new', x: width / 2 + 120, y: height * 0.92 }
  ];
  
  buttons.forEach(btn => {
    if (x >= btn.x - 40 && x <= btn.x + 40 &&
        y >= btn.y - 15 && y <= btn.y + 15) {
      handleAction(btn.action);
    }
  });
}

// 处理动作
function handleAction(action) {
  if (action === 'draw' && state.currentPlayer === 0) {
    if (state.tiles.length > 0) {
      state.currentDraw = state.tiles.pop();
      render();
    }
  } else if (action === 'play') {
    if (state.currentDraw) {
      state.discards.push(state.currentDraw);
      state.currentDraw = null;
      nextPlayer();
    } else if (state.selectedTile >= 0) {
      const tile = state.players[0].splice(state.selectedTile, 1)[0];
      state.discards.push(tile);
      state.selectedTile = -1;
      render();
      nextPlayer();
    }
  } else if (action === 'win') {
    alert('胡牌！');
  } else if (action === 'new') {
    newGame();
  }
}

// 下一个玩家
function nextPlayer() {
  state.currentPlayer = (state.currentPlayer + 1) % 4;
  render();
  
  if (state.currentPlayer !== 0) {
    setTimeout(aiTurn, 1000);
  }
}

// AI 回合
function aiTurn() {
  if (state.tiles.length > 0) {
    const drawn = state.tiles.pop();
    const discardIdx = Math.floor(Math.random() * state.players[state.currentPlayer].length);
    const discarded = state.players[state.currentPlayer].splice(discardIdx, 1)[0];
    state.discards.push(discarded);
    state.players[state.currentPlayer].push(drawn);
    render();
    nextPlayer();
  }
}

// 新游戏
function newGame() {
  createWall();
  dealTiles();
  render();
}

// 窗口大小变化
window.addEventListener('resize', initCanvas);

// 启动游戏
initCanvas();
newGame();
</script>
</body>
</html>
